<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack核心概念解析]]></title>
    <url>%2F2019%2F05%2F09%2Fwebpack%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Webpack核心概念解析终于忙完了论文，可以愉快的开始学习了，重拾起重学前端、webpack以及Vue的源码解读作为入职前的复习吧。整个webpack系列将分成五个大的部分进行，以webpack4.0为文档进行解读，从简单的概念解读到最后的实现。整个知识点涉及范围： loader使用loader来预处理文件，把不同的静态资源（模块的结尾不是js的模块)打包成js文件 loader打包静态资源打包图片 安装使用file-loader实现：npm install file-loader -D 在webpack.config.js中添加loader的配置 12345678910111213141516module.exports = &#123; //打包项目的入口文件 entry: &apos;./src/index.js&apos;, module:&#123; rules:[&#123; test:/\.(jpg|png|gif)$/,//打包以jpg、png、gif结尾的所有图片文件 use:&#123; loader:&apos;file-loader&apos;, options:&#123;//placeholder 占位符 name:&apos;[name]_[hash].[ext]&apos;,//保持原图片的名字+hash值和后缀,主要单引号 outputPath:&apos;image/&apos;//打包图片的位置 &#125; &#125; &#125;] &#125;&#125; 更多的有关于file-loader的配置见文档 打包图片成base64格式url-loader基本能实现file-loader的打包功能，适用于小图片的打包 好处：图片打包成js文件，不用加载图片的地址，页面快速显示 坏处：图片过大导致js文件过大 所以，当图片的大小小于limit值时会把图片打包成base64格式，大于limit值则按照file-loader打包成图片文件 安装使用url-loader实现：npm install url-loader -D 在webpack.config.js中添加loader的配置 1234567891011121314module.exports = &#123; module:&#123; rules:[&#123;//打包以jpg、png、gif结尾的所有图片文件 test:/\.(jpg|png|gif)$/, use:&#123; loader:&apos;url-loader&apos;, options:&#123;//placeholder 占位符 name:&apos;[name]_[hash].[ext]&apos;,//保持原图片的名字+hash值和后缀,主要单引号 outputPath:&apos;image/&apos;,//打包图片的位置 limit:2048 &#125; &#125;] &#125;&#125; 更多的有关于url-loader的配置见文档 打包样式css文件需要使用css-loader、style-loader css-loader:分析几个css文件的关系,合并css文件 style-loader:将css-loader合并的css内容挂载在页面的head部分 实现方式： 安装loader实现：npm install css-loader style-loader -D 在webpack.config.js中添加loader的配置 12345678module.exports = &#123; module: &#123; rules: [&#123;//打包css文件 test:/\.css$/, use:[&apos;style-loader&apos;,&apos;css-loader&apos;] &#125;] &#125;&#125; 更多的有关于css-loader的配置见文档 打包样式scss文件需要使用sass-loader、node-sass 安装loader实现：npm install sass-loader node-sass -D 在webpack.config.js中添加loader的配置12345678module.exports = &#123; module: &#123; rules: [&#123; test: /\.scss$/, use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;] &#125;] &#125;&#125;; 在配置中，有三个loader,执行顺序是从下到上，从右到左。在打包scss文件时，首先执行sass-loader：对sass翻译成css文件，在挂载到css-loader,最后style-loader. 更多的有关于sass-loader的配置见文档 为样式添加不同浏览器的前缀为了兼容不同的浏览器，在写样式的时候需要加上适用不同浏览器的前缀，如-o、-webkit、-moz等 -安装loader实现：npm install postcss-loader autoprefixer -D-在根目录创建postcss.config.js 12345moudle.exports =&#123; plugins:[ require(&apos;autoprefixer&apos;) ]&#125; 在webpack.config.js中添加loader的配置 123456789101112module.exports = &#123; module: &#123; rules: [&#123; test:/\.scss$/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;, &apos;postcss-loader&apos;] &#125;] &#125;&#125; 更多的有关于postcss-loader的配置见文档 css-loader添加不同的配置css模块化打包 场景：在文件引入的scss不仅影响当前的文件，还影响当前文件引入的其他js文件，造成样式冲突 实现：css只在当前模块类有效,在配置中添加modules:true开启css的模块化打包，在引入的时候注意区分scss文件的嵌套引用 场景：scss文件通过import引入其他scss文件，导致打包的时候引入的scss文件打包错误 实现：importLoader:2 在webpack.config.js中添加loader的配置 12345678910111213141516module:&#123; rules:[&#123;//打包scss文件 test:/\.scss$/, use:[ &apos;style-loader&apos;, &#123; loader:&apos;css-loader&apos;, options:&#123; importLoaders:2,//index.scss中通过import引入其他的scss文件,引入的scss文件在打包的时候也将依次经过所有的loader modules:true &#125; &#125;, &apos;sass-loader&apos;, &apos;postcss-loader&apos;] &#125;] &#125; 打包字体图标文件在阿里巴巴矢量图标库中，把需要的字体图标下载到本地，解压。将iconfont.eot iconfont.svg iconfont.ttf iconfont.woff 四种图片文件放入到项目中，在src中新建一个放字体图标的文件夹font。将iconfont.css文件拷贝到项目中，修改对应字体的引用路径。 需要安装 file-loader:npm i file-loader -D 在webpack.config.js中添加loader的配置 12345678910111213module.exports = &#123; ... module: &#123; rules: [&#123; test: /\.(eot|ttf|svg|woff)$/, use:&#123; loader:&apos;file-loader&apos; &#125; &#125;, ] &#125;] &#125;&#125; 更多的有关于加载字体的配置见文档 打包数据文件如遇到json、scv、xml文件需要打包时，使用csv-loader 和 xml-loader实现。 安装：npm install csv-loader xml-loader -D 在webpack.config.js中添加loader的配置 12345678910111213141516module.exports = &#123; module: &#123; rules: [&#123; test: /\.(csv|tsv)$/, use: [ &apos;csv-loader&apos; ] &#125;, &#123; test: /\.xml$/, use: [ &apos;xml-loader&apos; ] &#125;] &#125;&#125; 更多的有关于加载数据的配置见文档 pluginsloaders可以将各个类型的静态资源打包成webpack能处理的模块，而plugins有更强大的功能。它可以从打包优化和压缩，一直到重新定义环境中的变量。 plugin可以在webpack运行到某一个时刻，自动完成一些事情。 自动生成html文件，并引入打包生成的js文件到生成的html文件中 安装使用HtmlWebpackPlugin实现：npm install html-webpack-plugin -D 在webpack.config.js中添加loader的配置 在src中创建一个html的模板，在HtmlWebpackPlugin的配置中引入该模板，打包后生成和模板类似的html文件并引入打包的js文件。 12345678910111213const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;index.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), filename: &apos;index_bundle.js&apos; &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; &#125;)]&#125; 更多的有关于HtmlWebpackPlugin的配置见文档 自动清除上一次打包的dist文件先删除上一次打包的dist文件，再执行打包 安装使用CleanWebpackPlugin 实现：npm install clean-webpack-plugin -D 在webpack.config.js中添加loader的配置 1234567891011121314151617const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;index.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;./dist&apos;), filename: &apos;index_bundle.js&apos; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; &#125;), new CleanWebpackPlugin([&apos;dist&apos;]), // 在打包之前，可以删除dist文件夹下的所有内容 ]&#125; 更多的有关于CleanWebpackPlugin的配置见文档Entry与Output的基础配置 需求：打包多个入口文件，对应的在出口的配置中注意命名filename避免出口文件名字冲突—-使用占位符)来确保每个文件具有唯一的名称 需求：打包后的文件，作为后端的接口文件，静态资源需要上传到cdn，在output中进行配置，提前加入cdn的地址。在编译时，如果不知道publicPath的地址，可以留空，在入口起点文件运行时动态设置。__webpack_public_path__ = myRuntimePublicPath 123456789101112131415module.exports = &#123; mode: &apos;development&apos;, entry: &#123; main: &apos;./src/index.js&apos;, sub: &apos;./src/index.js&apos; &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; &#125;), new CleanWebpackPlugin([&apos;dist&apos;])], output: &#123; publicPath: &apos;http://cdn.com.cn&apos;, //加入cdn地址 filename: &apos;[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;&#125; 更多的有关于output的配置见文档SourceMap的配置 SourceMap是一个映射关系，打包文件和源文件的映射关系，用于开发者的调试。 在devtool中进行设置：devtool: &#39;source-map&#39;打包速度会降低，在dist里面会有map映射文件 常用设置devtool说明: none:在开发者模式下，默认开启sourcemap,将其关闭 inline前缀：不单独生成map文件，把对应的map文件以base64的形式直接打包到js文件。 cheap前缀：sourcemap和打包后的js同行显示，并没有映射到列忽略源自 loader 的 source。 map，并且仅显示转译后的代码，所以打包速度相对来说较快。代码出错提示不用精确显示第几行的第几个字符出错，只显示第几行出错，会提高一些性能， moudle前缀：不仅映射业务代码，还会包括loader、第三方模块的错误。 eval前缀：打包速度最快。 development环境推荐使用： devtool: &#39;cheap-module-eval-source-map&#39; production环境推荐使用： devtool: &#39;cheap-module-source-map&#39; 更多的有关于devtool文档 使用WebpackDevServer提升开发效率场景：每次在src里编写完代码都需要手动重新运行 npm run bundle，如何自动解决？ -安装：npm install webpack-dev-server –D devServer参数说明 contentBase :配置开发服务运行时的文件根目录 open :自动打开浏览器 host：开发服务器监听的主机地址 compress :开发服务器是否启动gzip等压缩 port：开发服务器监听的端口 在 webpack.config.js 中，加 devServer 12345678910111213141516const path = require(&apos;path&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);module.exports = &#123; mode: &apos;development&apos;, devtool: &apos;cheap-module-eval-source-map&apos;, devServer: &#123; contentBase: &apos;./dist&apos;, open: true, port: 8080 proxy:&#123;//配置跨域，访问的域名会被代理到本地的3000端口 &apos;/api&apos;: &apos;http://localhost:3000&apos; &#125; &#125;&#125; 在 package.json 中配置 1234567891011&#123; &quot;name&quot;: &quot;banggan&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack-dev-server&quot;, &#125;,&#125; 更多的有关于devServer文档 如何实现自己写一个类似webpackdevserver的工具 在package.json 中配置创建一个新的指令，npm run server运行自己写的类似webpackdevserver的工具 123456789101112&#123; &quot;name&quot;: &quot;banggan&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack-dev-server&quot;, &quot;server&quot; : &quot;node server.js&quot; &#125;,&#125; 安装express:npm install express webpack-dev-middleware -D 在根目录创建一个server.js 在node中直接使用webpack:webpack（config) 12345678910111213const express = require(&apos;express&apos;); //引入expressconst webpack = require(&apos;webpack&apos;);//引入webpackconst webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;);const config = require(&apos;./webpack.config.js&apos;);//引入配置文件const complier = webpack(config); //编译一次吗，打包一次代码const app = express();//创建express实例app.use(webpackDevMiddleware(complier, &#123;&#125;));app.listen(3000, () =&gt; &#123;//监听3000端口 console.log(&apos;server is running&apos;);&#125;); Hot Module Replacement热模块更新 场景:在程序运行中。替换、添加、替换某个模块，不需要重新加载整个页面，实现交互时更新。 在 webpack.config.js 中，添加配置 123456789101112131415161718module.exports = &#123; mode: &apos;development&apos;, devtool: &apos;cheap-module-eval-source-map&apos;, devServer: &#123; contentBase: &apos;./dist&apos;, open: true, port: 8080, hot: true,//开启热更新功能 hotOnly: true//如果html功能没有实现，也不让浏览器刷新 &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; &#125;), new CleanWebpackPlugin([&apos;dist&apos;]), new webpack.HotModuleReplacementPlugin()//使用热模块插件 ],&#125; 在main.js文件中，使用 HotModuleReplacementPlugin 启用模块的热替换功能。接口暴露在moudle.hot属性下面 123456//如果模块启用了HMR，就可以用 module.hot.accept(),监听模块的更新。if (module.hot) &#123; module.hot.accept(&apos;./library.js&apos;, function() &#123; // 使用更新过的 library 模块执行某些操作... &#125;)&#125; 1234//拒绝给定依赖模块的更新，使用 &apos;decline&apos; 方法强制更新失败。module.hot.decline( dependencies // 可以是一个字符串或字符串数组) 注意：引入css文件时,用框架Vue，React 时，不需要写 module.hot.accept()，因为在使用css-loader，vue-loader，babel-preset时，均配置好了HMR，不需要自己重新写如果文件没有内置HMR，需要自己手动写监听模块更新代码 结合Bable处理ES6语法 场景：代码中含有ES6/ES7的代码，为了让低版本的浏览器兼容代码，需要使用Bable进行转换 安装:Bable官网 1234//preset-env语法转换npm install babel-loader @babel/core @babel/preset-env -D//兼容低版本浏览器的语法，函数的补充npm install --save @babel/polyfill 在 webpack.config.js 中，添加配置 1234567891011121314151617181920module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, //排除在外：在node_modules中的js，babel-loader不生效 loader: &quot;babel-loader&quot; , options:&#123; &quot;presets&quot;: [[&quot;@babel/preset-env&quot;,&#123; targets: &#123; edge: &quot;17&quot;, firefox: &quot;60&quot;, chrome: &quot;67&quot;, safari: &quot;11.1&quot;, &#125;,//运行在大于**版本的浏览器上，，已经支持es6的高浏览器不需要转换为es5 useBuiltIns:&apos;usage&apos; //按需添加polyfill,把业务代码中的新语法新函数都转成低版本浏览器兼容的 &#125;]] &#125; &#125; ]&#125; 在src目录下的index.js中顶部位置导入import &quot;@babel/polyfill&quot;; 注意如果不是打包业务代码，而是写的类库、或者z组件库的时候不能使用@babel/polyfill实现，因为会导致声明的变量变成全局变量，污染全局环境。使用plugin-transform-runtime实现 安装插件 123npm install --save-dev @babel/plugin-transform-runtimenpm install --save @babel/runtimenpm install --save @babel/runtime-corejs2 在 webpack.config.js 中，添加配置1234567891011121314151617module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot; , options:&#123; &quot;plugins&quot;: [[&quot;@babel/plugin-transform-runtime&quot;,&#123; &quot;corejs&quot;: 2, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125;]] &#125; &#125; ]&#125; 由于babel配置的内容较多，官网推荐在根目录下创建属于babel的配置文件.babelrc文件 由于babel需要配置的内容非常多，我们需要在项目根目录下创建一个 .babelrc 文件。就不需要在 webpack.config.js 中写 babel 的配置了。在 .babelrc 中： 12345678&#123; &quot;plugins&quot;: [[&quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;corejs&quot;: 2, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125;]]&#125; 总结 在webpack.config.js中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667module.exports = &#123; mode: &apos;development&apos;, //开发环境进行打包，打包的代码不会压缩 devtool: &apos;cheap-module-eval-source-map&apos;,//不带列信息，只对业务代码进行sourcemap的生成 entry: &#123;//配置入口文件 main: &apos;./src/index.js&apos; &#125;, devServer: &#123;//配置webpack，开发环境的调试 contentBase: &apos;./dist&apos;,//启动服务器的目录 open: true,//打开新的端口号8080 port: 8080, hot: true,//打开热替换功能 hotOnly: true &#125;, module: &#123;//对不同的文件进行打包规则 rules: [&#123; test: /\.js$/, //对js文件的babel-loader打包，其配置在.babelrc文件中 exclude: /node_modules/, //排除在外：在node_modules中的js，babel-loader不生效 loader: &apos;babel-loader&apos;, &#125;, &#123; test: /\.(jpg|png|gif)$/,//对图片进行打包 use: &#123; loader: &apos;url-loader&apos;, options: &#123; name: &apos;[name]_[hash].[ext]&apos;, outputPath: &apos;images/&apos;, limit: 10240//小于10240以base64的形式进行打包 &#125; &#125; &#125;, &#123; test: /\.(eot|ttf|svg)$/,//字体文件的打包 use: &#123; loader: &apos;file-loader&apos; &#125; &#125;, &#123; test: /\.scss$/,//scss文件的打包，先用postcss-loader，在用sass-loader进行解析，最后css-loader进行挂载 use: [ &apos;style-loader&apos;, &#123; loader: &apos;css-loader&apos;, options: &#123; importLoaders: 2 &#125; &#125;, &apos;sass-loader&apos;, &apos;postcss-loader&apos; ] &#125;, &#123; test: /\.css$/,//css文件的打包，没有sass-loader的解析 use: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos; ] &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &apos;src/index.html&apos; &#125;), new CleanWebpackPlugin([&apos;dist&apos;]),//自动清空上一次打包 new webpack.HotModuleReplacementPlugin()//热替换插件 ], output: &#123;//出口文件 filename: &apos;[name].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;&#125;]]></content>
      <categories>
        <category>webpack解读</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loader</tag>
        <tag>plugins</tag>
        <tag>HMR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack解读之LOADER]]></title>
    <url>%2F2019%2F04%2F27%2Fwebpack%E8%A7%A3%E8%AF%BB%E4%B9%8BLOADER%2F</url>
    <content type="text"><![CDATA[Webpack核心概念解析终于忙完了论文，可以愉快的开始学习了，重拾起重学前端、webpack以及Vue的源码解读作为入职前的复习吧。整个webpack系列将分成五个大的部分进行，以webpack4.0为文档进行解读，从简单的概念解读到最后的实现。整个知识点涉及范围： loader使用loader来预处理文件，把不同的静态资源（模块的结尾不是js的模块)打包成js文件 loader打包静态资源打包图片 安装使用file-loader实现：npm install file-loader -D 在webpack.config.js中添加loader的配置 12345678910111213141516module.exports = &#123; //打包项目的入口文件 entry: &apos;./src/index.js&apos;, module:&#123; rules:[&#123; test:/\.(jpg|png|gif)$/,//打包以jpg、png、gif结尾的所有图片文件 use:&#123; loader:&apos;file-loader&apos;, options:&#123;//placeholder 占位符 name:&apos;[name]_[hash].[ext]&apos;,//保持原图片的名字+hash值和后缀,主要单引号 outputPath:&apos;image/&apos;//打包图片的位置 &#125; &#125; &#125;] &#125;&#125; 更多的有关于file-loader的配置见文档 打包图片成base64格式url-loader基本能实现file-loader的打包功能，适用于小图片的打包 好处：图片打包成js文件，不用加载图片的地址，页面快速显示 坏处：图片过大导致js文件过大 所以，当图片的大小小于limit值时会把图片打包成base64格式，大于limit值则按照file-loader打包成图片文件 安装使用url-loader实现：npm install url-loader -D 在webpack.config.js中添加loader的配置 1234567891011121314module.exports = &#123; module:&#123; rules:[&#123;//打包以jpg、png、gif结尾的所有图片文件 test:/\.(jpg|png|gif)$/, use:&#123; loader:&apos;url-loader&apos;, options:&#123;//placeholder 占位符 name:&apos;[name]_[hash].[ext]&apos;,//保持原图片的名字+hash值和后缀,主要单引号 outputPath:&apos;image/&apos;,//打包图片的位置 limit:2048 &#125; &#125;] &#125;&#125; 更多的有关于url-loader的配置见文档 打包样式css文件需要使用css-loader、style-loader css-loader:分析几个css文件的关系,合并css文件 style-loader:将css-loader合并的css内容挂载在页面的head部分 实现方式： 安装loader实现：npm install css-loader style-loader -D 在webpack.config.js中添加loader的配置 12345678module.exports = &#123; module: &#123; rules: [&#123;//打包css文件 test:/\.css$/, use:[&apos;style-loader&apos;,&apos;css-loader&apos;] &#125;] &#125;&#125; 更多的有关于css-loader的配置见文档 打包样式scss文件需要使用sass-loader、node-sass 安装loader实现：npm install sass-loader node-sass -D 在webpack.config.js中添加loader的配置12345678module.exports = &#123; module: &#123; rules: [&#123; test: /\.scss$/, use:[&apos;style-loader&apos;,&apos;css-loader&apos;,&apos;sass-loader&apos;] &#125;] &#125;&#125;; 在配置中，有三个loader,执行顺序是从下到上，从右到左。在打包scss文件时，首先执行sass-loader：对sass翻译成css文件，在挂载到css-loader,最后style-loader. 更多的有关于sass-loader的配置见文档 为样式添加不同浏览器的前缀为了兼容不同的浏览器，在写样式的时候需要加上适用不同浏览器的前缀，如-o、-webkit、-moz等 -安装loader实现：npm install postcss-loader autoprefixer -D-在根目录创建postcss.config.js 12345moudle.exports =&#123; plugins:[ require(&apos;autoprefixer&apos;) ]&#125; 在webpack.config.js中添加loader的配置 123456789101112module.exports = &#123; module: &#123; rules: [&#123; test:/\.scss$/, use:[ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;, &apos;postcss-loader&apos;] &#125;] &#125;&#125; 更多的有关于postcss-loader的配置见文档 css-loader添加不同的配置css模块化打包 场景：在文件引入的scss不仅影响当前的文件，还影响当前文件引入的其他js文件，造成样式冲突 实现：css只在当前模块类有效,在配置中添加modules:true开启css的模块化打包，在引入的时候注意区分scss文件的嵌套引用 场景：scss文件通过import引入其他scss文件，导致打包的时候引入的scss文件打包错误 实现：importLoader:2 在webpack.config.js中添加loader的配置 1234567891011121314151617module:&#123; rules:[&#123;//打包scss文件 test:/\.scss$/, use:[ &apos;style-loader&apos;, &#123; loader:&apos;css-loader&apos;, options:&#123; importLoaders:2,//index.scss中通过import引入其他的scss文件,引入的scss文件在打包的时候也将依次经过所有的loader modules:true &#125; &#125;, &apos;sass-loader&apos;, &apos;postcss-loader&apos;] &#125;] &#125; 打包字体图标文件在阿里巴巴矢量图标库中，把需要的字体图标下载到本地，解压。将iconfont.eot iconfont.svg iconfont.ttf iconfont.woff 四种图片文件放入到项目中，在src中新建一个放字体图标的文件夹font。将iconfont.css文件拷贝到项目中，修改对应字体的引用路径。 需要安装 file-loader:npm i file-loader -D 在webpack.config.js中添加loader的配置 12345678910111213module.exports = &#123; ... module: &#123; rules: [&#123; test: /\.(eot|ttf|svg|woff)$/, use:&#123; loader:&apos;file-loader&apos; &#125; &#125;, ] &#125;] &#125;&#125; 更多的有关于加载字体的配置见文档 打包数据文件如遇到json、scv、xml文件需要打包时，使用csv-loader 和 xml-loader实现。 安装：npm install csv-loader xml-loader -D 在webpack.config.js中添加loader的配置 12345678910111213141516module.exports = &#123; module: &#123; rules: [&#123; test: /\.(csv|tsv)$/, use: [ &apos;csv-loader&apos; ] &#125;, &#123; test: /\.xml$/, use: [ &apos;xml-loader&apos; ] &#125;] &#125;&#125; 更多的有关于加载数据的配置见文档]]></content>
      <categories>
        <category>webpack解读</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>loader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发者应该明白的浏览器工作原理]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E6%98%8E%E7%99%BD%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言作为前端开发，我们平常跟浏览器打交道的时间也是最多的。在前端面试中，一个较为经典的问题：在浏览器地址中输入url地址，敲回车，发生了什么？浏览器究竟做了什么？相信很多人脑海里都会出现个大概的轮廓，可是一到细化具体的过程就答不上来。那么，作为前端开发者，应该从哪些方面延伸来回答这个问题呢？ 浏览器工作流程对于浏览器来说，当在地址栏输入url地址，浏览器所做的事情就是把一个url变成一个在屏幕上显示的网页,大致的过程是这样的：从HTTP请求回来 ，产生流食的数据，DOM的构建、CSS计算、渲染、绘制，都是尽可能的流式处理前一步的产出，不需要等待上一步完全接受才开始处理，所以我们在浏览网页的时候，才会逐步出现页面。 浏览器接受url开启一个网络请求线程 浏览器发出一个完整的http请求 服务器接收请求到后台接收请求 使用http请求请求页面 把请求回来的html代码解析成DOM树 CSS的可视化格式模型解析 根据CSS属性对元素进行渲染，得到内存中的位图 对位图的合成 绘制页面 浏览器接受url开启网络请求线程第一点主要涉及的是浏览器的进程、线程模型以及JS的运行机制： 多进程的浏览器浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等。 Browser进程：浏览器的主进程（负责协调、主控），只有一个 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制 浏览器渲染进程（内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程） 多线程的浏览器内核每一个tab页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程： GUI线程 JS引擎线程 事件触发线程 定时器线程 网络请求线程 开启网络线程发出一个完整的http请求该部分主要包括：dns查询、tcp/ip请求构建、五层因特网等内容 DNS查询如果输入的是域名，需要进行dns解析成IP，大致流程： 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host 如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP。 tcp/ip请求 这里的tcp/ip请求需要了解3次握手规则建立连接以及断开连接时的四次挥手,可以参考之前的博客：https://blog.csdn.net/bangbanggangan/article/details/81031639 五层因特网协议其实这个概念挺难记全的，记不全没关系，但是要有一个整体概念。其实就是一个概念：从客户端发出http请求到服务器接收，中间会经过一系列的流程。简括就是：从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。当然，服务端的接收就是反过来的步骤。五层因特尔协议栈其实就是： 1.应用层(dns,http) 2.传输层(tcp,udp) 建立tcp连接（三次握手） 3.网络层(IP,ARP) IP寻址 4.数据链路层(PPP) 5.物理层OSI七层框架： 物理层、 数据链路层、 网络层、 传输层、 会话层、 表示层、 应用层。表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程 网络通讯HTTP协议HTTP协议是基于TCP协议出现的，在TCP的基础上规定了Request-Response的模型，决定了通讯必须由浏览器端发起的，首先来了解下HTTP协议的格式： HTTP协议格式HTTP协议大致可以分成以下部分：其中path是请求路径、version是固定的字符串，依次介绍下面的每个部分： HTTP Method 请求方法在requestline里面的方法部分，表示HTTP的操作类型，常见的几种请求方法如下： GET：浏览器通过地址访问页面均属于get请求 POST：常见的表单提交 HEAD ：跟get类似，区别在于只返回请求头 PUT：表示添加资源 DELETE：表示删除资源 CONNECT： 多用于HTTPS和WebSocket OPTIONS TRACE HTTP Status code状态码常见的状态码有以下几种： 1xx：临时回应 2xx：请求成功，如200 3xx：请求目标有变化，如301和302表示临时和永久重定向，304表示客户端没有更新内容 4xx;请求错误，如403无权限，404访问的资源不存在 5xx：服务端错误，如500服务端错误，503服务端暂时错误等 在前端开发中，最熟悉的系列无非是大家都喜欢的200请求成功的标志，在面试中，问得较多的是304缓存问题和301、302重定向的问题。 HTTP HEAD（HTTP头）HTTP头可以看做是一个键值对，在HTTP标准中，Request Header如下图：Response Header如下图：在实际的开发中，完整的列表可以参考rfc2616标准。 HTTP Request BodyHTTP请求的body主要用于表单的提交，常见的body格式： application/json application/x-www-form-urlencoded:使用form标签提交的html请求，默认产生 multipart/form-data:当有文件上传时，使用的格式 HTTPSHTTPS在HTTP的基础上增加了两个作用，一是确定请求的目标服务端身份，二是保证传输的数据不会被篡改或者窃听，该协议使用加密通道来传输HTTP内容，所以首先需要与服务端简历TLS加密通道。可以在此处查看详情：https://tools.ietf.org/html/rfc2818 HTTP2HTTP2是HTTP1.1的升级版，有两大改进：一是支持服务端推送，二是支持TCP链接复用：则使用同一个TCP链接来传输多个HTTP请求。详情见:https://tools.ietf.org/html/rfc7540 构建DOM树当浏览器使用HTTP向服务端请求页面后，那么如何去解析请求回来的HTML代码、构建DOM树呢？ 字符流如何解析成词首先浏览器读取获取的HTML，根据指定的文件编码方式如UTF-8转换为字符流，再将字符串转换为词Token。那什么是词？词是编译原理中的最小单元，如标签开始、属性、标签结束、注释、CDATA节点。Token会标识出当前Token的种类。举个列子：&lt;p class=&quot;a&quot; &gt;hello&lt;/p&gt; 这里就可以拆分成&lt;p（p标签的开始）、class=”a”（属性）、&gt;（p标签的结束）、hello（文本）、&lt;/p&gt;（结束标签） 构建DOM树接下来就是将词变成DOM树。在构建DOM树时，是一边生成Token一边消耗Token来生成节点的。 &lt;html&gt; &lt;head&gt; &lt;title&gt;Web page parsing&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h1&gt;Web page parsing&lt;/h1&gt; &lt;p&gt;This is an example Web page.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 构建的DOM树： 构建CSSOM在构建完DOM树，当前的对象只包含节点和属性，没有任何样式信息，那么浏览器是如何给DOM树添加CSS属性呢？我们知道浏览器是流式的处理整个过程，我们拿到DOM树构造好的元素，依次去检查他匹配的规则，再根据规则的优先级，做覆盖和调整。 构建渲染树当CSSOM树和DOM树都得到之后，将两个树进行合并就得到了渲染树： 布局与绘制当浏览器生成渲染树以后，就会根据渲染树来进行布局。在这个过程中，每一个元素都要要弄清楚各个节点在页面中的确切位置和大小，把对应的盒变为相应的位图。一个元素可能对应多个盒（如内联元素，可能被分成多行）每一个盒都对应着一个位图。合成把部分位图合成变成合成层。最终的绘制过程就是把位图合成层绘制到屏幕上。这里提一个常见的问题，重绘和回流？具体的相关知识参考：https://segmentfault.com/a/1190000017329980 总结浏览器的工作流程大致就是： 构建DOM树-构建CSSOM-构建渲染树-布局-绘制]]></content>
      <categories>
        <category>浏览器相关</category>
      </categories>
      <tags>
        <tag>浏览器工作原理，HTTP，DOM树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端之HTML语义]]></title>
    <url>%2F2019%2F01%2F25%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8BHTML%E8%AF%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[HTML的语义类标签在我们的工作中经常遇见的，语义是我们说话表达的意思，多数的语义实际是从文字继承而来的。语义类的标签是纯文字的补充。 为什么要用语义标签？正确使用语义标签的好处在于： 语义类标签对开发者更为友好：增强可读性，清晰的网页结构，方便团队的开发和维护。 有利于SEO搜索引擎检索。 并不是说不管什么场景都尽量使用语义类标签，不恰当的使用反而会造成冗余，如ul无序列表，很多时候我们都给并列关系的元素套上ul: I have lived in the following countries: China Norway UT 由此可见，ul出现在行文中间，它的上文多数在于提示列举的某些项，但如果所有并列关系都用ul，会造成冗余标签。 重要的几个使用场景作为自然语言的延伸作为自然语言和纯文本的补充，用来表达一定的结构。如在HTML5中提出的特定文档级别的语义： ruby语义化ruby是一种排版注释系统，位于横排基础文本上方的简短文字，如下图： ruby设计的元素包括ruby、rt、rp,使用ruby指定一个具体的表达式，rt提供说明，rt部分将显示子表达式的上方：12345&lt;ruby&gt; 友&lt;rt&gt;bi&lt;/rt&gt; 善&lt;rt&gt;shi&lt;/rt&gt; 的眼神&lt;ruby&gt; 但是在不支持ruby的浏览器中需要使用rp对这两个区块进行视觉上的隔离。1234567891011 &lt;ruby&gt; 友 &lt;rp&gt; &lt;rt&gt;bi&lt;/rt&gt; &lt;/rp&gt; 善 &lt;rp&gt; &lt;rt&gt;shi&lt;/rt&gt; &lt;/rp&gt; 的眼神&lt;/ruby&gt; 略微改变的元素比如使用em和strong来强调一段重要的文本，cite用来为对参考文献的引用进行定义，比如书籍或杂志的标题。small不仅仅指的是小字体，它还同样为法律声明增添不具有重要性的旁注或小字。hr现在表达的是主体性的间断，不再仅仅是分割版面的一条水平线。 mark高亮标记可以使用mark元素来标记出网页里被搜索的关键词或是用于高亮显示一段解释性的代码。 作为标题摘要作为文章的结构的提现，语义化的HTML还能支持自动生成目录结构；如h1-h6是html中基础的标题，表示了文章不同层级的标题。有时候，会有副标题，为了避免副标题产生额外的层级，使用hgroup标签： 作为整体结构应用语义结构的页面，可以明确的提示出页面信息的主次关系，能让浏览器更好的支持阅读视图功能：如一个典型的body结构：12345678910111213141516&lt;body&gt; &lt;header&gt; &lt;nav&gt; ...... &lt;/nav&gt; &lt;/header&gt; &lt;aside&gt; &lt;nav&gt; ....... &lt;/nav&gt; &lt;/aside&gt; &lt;section&gt; ....&lt;/section&gt; &lt;footer&gt; &lt;address&gt; .....&lt;/address&gt; &lt;/footer&gt;&lt;/body&gt; header，出现在头部，表示导航或者介绍性的信息。 footer,出现在尾部，包含作者信息、相关的链接。 nav，表示页面的导航，可以通过导航连接到网站的其他页面，或者当前页面的其它部分. &lt;nav&gt;不但可以作为页面独立的导航区域存在，我们还可以在&lt;header&gt;标签中使用。此外，&lt;nav&gt;标签还可以显示在侧边栏中。由此可见，一个页面之中可以有多个&lt;nav&gt;标签。 根据HTML5标准，&lt;nav&gt;标签只用于页面的主要导航部分。因为搜索引擎或者屏幕阅读器会根据&lt;nav&gt;标签来确定网站的主体内容，所以并不是任意一组超链接都适合放置在&lt;nav&gt;标签中,我们只要将主要的，基本的链接组放进&lt;nav&gt;即可,对于有辅助性的页脚链接则不推荐使用&lt;nav&gt;标签。 aside,所包含的内容不是页面的主要内容、具有独立性，是对页面的补充。&lt;aside&gt;标签一般使用在页面、文章的侧边栏、广告、友情链接等区域。 article,表示包含于一个文档、页面、应用程序或网站中的一段独立的内容，可以被独立的发布或者重新使用文章标记标签。 &lt;article&gt;标签应该使用在相对比较独立、完整的的内容区块，所以我们可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用它。通常情况下，一个&lt;article&gt;元素包括标题、正文和脚注。和&lt;nav&gt;标签一样，该标签同样不能用在&lt;address&gt;标签中 实际分析布局通过一个很论文很像的例子来深入理解语义类标签，如下页面：https://en.wikipedia.org/wiki/World_Wide_Web 重要的布局我已经用红框框出来了: 简要分析一下： aside：左侧的侧边栏属于aside，一般是具有导航性质的内容。 article:文章的主体部分，属于一段独立的内容 hgroup，h1~h6:hgroup属于标题组，这里的实现： 1234&lt;hgroup&gt; &lt;h1&gt;WWorld Wide Web&gt;&lt;/h1&gt; &lt;h2&gt;From Wikipedia, the free encyclopedia&gt;&lt;/h2&gt;&lt;/hgroup&gt; abbr：缩写，这里的WWW是WWorld Wide Web的缩写，这里的实现：&lt;abbr title=&quot;WWorld Wide Web&quot;&gt;www&lt;/abbr&gt; hr:水平分割线，在标准的定义中，是故事走向的转变或话题的转变，应该使用border实现 strong：加粗blockquote blockquote，q，cite：表示引述，blockquote表示段落级的引述内容，q表示行内的引述内容，cite表示引述的作品名 figure，figcaption:用于表示与主文章相关的图像,这里的实现： 1234&lt;figure&gt; &lt;img src=&quot;&quot; /&gt; &lt;figcaption&gt;The.......&lt;/figcaption&gt;&lt;/figure&gt; dfn:包裹白定义的名词，这里的实现：The &lt;dfn&gt;Internet&lt;/dfn&gt; is a .... nav，ol,ul:目录的链接，使用nav标签，ol和ul是区分有无顺序 pre,samp,code：pre预先排版内容，samp用于计算机的程序输出， 这里嵌入的代码和预先编号的段落，是一段灰色背景的文字，这里的实现：1234&lt;pre&gt;&lt;samp&gt;GET /home.hrml HTTP/1.1Host:www.example.org&lt;/samp&gt;&lt;/pre&gt; 附上其他一些标签及说明：]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重学前端之知识架构]]></title>
    <url>%2F2019%2F01%2F25%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E4%B9%8B%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言近期在极客时间上非常火的一个课程-重弄学前端，由前淘宝的前端负责人讲解的专栏，想以此作为一个导航，来夯实自己的前端知识，搭建自己的前端知识框架，明确学习的终点，精进前端技术。 学习路线与方法建立知识架构在看专栏之前，自己的知识架构大概就是分语言的：JavaScript负责交互、css负责样式、html负责页面，框架类，大前端的范畴等，然后再具体的下分到每种语言的各种知识点，看了专栏之后，才发现自己的划分没有完备性，总会出现结构之外的知识点，总觉得自己的知识欠缺，不够深入。 所谓知识的完备性，就是任何的知识点都不会出现在你的知识架构之外。像winter老师说的一样：用规定的文法、语法，去表达特定的语义，最终操作运行。 学会追本溯源关注知识点提出的背景，关注提出的原始目的，深入知识点的内部，比如： 对重要的知识点多进行分析以及运用 用过的东西不能只停留在会用的阶段，追溯到源码 对于框架的使用没必要花太多时间，应该多研究一下三大框架背后的设计思想。前端知识架构前端的知识架构总体上分为基础部分和实践部分：基础部分包含了JavaScript、CSS和HTML、浏览器的实现原理和API；实践部分包含的是在实际开发中遇到的问题以及如何去分析问题，解决问题。JavaScript在 JavaScript 的模块中，首先我们可以把语言按照文法、语义和运行时来拆分，这符合编程语言的规律：用一定的词法和语法。去表达一定的语义，从而操作运行时： 根据程序的运行规律，将运行时分为数据结构和执行过程部分：数据结构包含类型和事列，所谓的执行过程就是JavaScript的执行过程。 文法中的词法和语义基本是一一对应的，而语义的大部分在运行的时候就会涉及到。 HTML和CSS在HTML部分，按照功能和语言来划分，把这部分就分为： 文档元信息：通常是出现在 head标签中的元素，包含了描述文档自身的一些信息； 语义相关：扩展纯文本、表达文章的结构标签； 链接：到文档内和文档外的连接； 替换性标签：声音、图片、视频、音频等外部元素来替换自身的一类标签； 表单表格：填写和提交信息的一类标签以及相关的表格的结构； 在CSS部分，大致分为布局、绘制和交互等方面，如在布局常用的正常流和弹性布局； 浏览器的实现原理和 API 浏览器部分会从浏览器的运行机制出发。按照解析、构建DOM树、CSS、渲染树、合成和绘制的流程来实现；在API部分，从W3C的标准的几个块来，主要是事件、DOM.CSSOM等； 前端工程实践从实际的开发角度出发，分为性能的优化、工具链、持续集成、搭建系统、架构等方面。 总结这些划分基本上按照课程来的，但是在学习的过程，也希望自己在这份知识架构中，在知识框架里找到落实的地方，重新去学习，完备自己的知识库。]]></content>
      <categories>
        <category>重学前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之对象类型]]></title>
    <url>%2F2019%2F01%2F21%2FTypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在TypeScript中，利用接口(Interfaces)来定义对象的类型。 在面向对象语言中，接口（Interfaces）、它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。在TypeScript中没有接口的概念，在编译成JavaScript的时候，所有的接口会被擦出掉，而TypeScript的核心之一就是类型检查。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约并让代码看起来更好理解。 TypeScript中的接口可用于对对象的形状进行描述，也可用于对类的一部分进行抽象，如：12345678910111213interface Person &#123; name:string; age：number;&#125;function put(person:Person)&#123; console.log(&quot;hello&quot; + person.name+&quot;I&apos;m&quot;+ person.age);&#125;let Tom: Person = &#123; //这里的对象只要包含必要的属性且值类型正确就可以 name: &apos;Tom&apos;, age: 25&#125;; 如果不给传进去的对象指定是接口类型的数据，那么传入的对象参数可以包含其他属性，编译器会检查必要的属性是否存在且判断类型是否正确。如果是是指定了接口类型的数据，多属性和少属性均会出错123456789let Tom: Person = &#123;//两种情况均不允许 name: &apos;Tom&apos;&#125;;let Tom: Person = &#123; name: &apos;Tom&apos;, age: 25, gender: &apos;male&apos;&#125;; 可选属性在实际的开发中，接口里的属性不全是需要的，就可以使用可选属性： 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。 12345678910111213//这里name和age均是可选属性，在传对象的时候name和age可有可无interface Person &#123; name?: string; age?: number;&#125;function getInfo(p:person)&#123; console.log(p.name); console.log(p.age);&#125;let Tom =&#123;name:&apos;tom&apos;&#125;let Tom =&#123;age:20&#125;getInfo(Tom); 任意属性如果我们希望一个借口有任意的属性，可使用 [propName: string]: any来实现：12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let Tom: Person = &#123; name: &apos;Tom&apos;, gender: &apos;male&apos;&#125;; 一旦定义了任意属性，则确定和可选属性必须是他的子属性。123456let tom: Person = &#123; name: &apos;Tom&apos;, age: 25, gender: &apos;male&apos;&#125;;//error TS2411: Property &apos;age&apos; of type &apos;number&apos; is not assignable to string index type &apos;string&apos;. 这里的任意属性是string，而age是number，number不是string的子属性，所以报错 只读属性如果我们希望对象的属性只能在对象创建时候修改其值，在属性名的前面用readonly来指定只读属性：123456789101112131415interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: &apos;Tom&apos;, gender: &apos;male&apos;&#125;;tom.id = 9527;//error TS2540: Cannot assign to &apos;id&apos; because it is a constant or a read-only property. 定义只读数组TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：123let a: ReadonlyArray&lt;number&gt; =[1,2,3,4];a[0] =2;//errora.length = 9;//error 函数类型为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。123456789interface getStr&#123;/* 函数传入两个number类型的参数，返回一个string*/ (x:number,y:number):string;&#125;let myStr: getStr;myStr = function(grade:number,class:nember)&#123; return `$&#123;grade&#125;年级$&#123;class&#125;班`;&#125;console.log(myStr(2,3)); //2年级3班 可索引类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;];let myStr: string = myArray[0];//打印Bob 定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值 TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 类类型一个类去实现接口，而不是直接把接口拿来用12345678910111213interface Clock&#123;//定义一个由属性和方法的接口 currentTime:Date; setTime(d:Date);&#125;//Time类实现了Clock接口class Time implements Clock&#123; currentTime:Date; setTime(d:Date)&#123; this.currentTime = d &#125; constructor(h: number, m: number) &#123; &#125;//类的静态部分，不会检查&#125; 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。123456789//接口可以继承接口 并且可以多继承interface shape&#123; color:string;&#125;interface pen extends shape&#123; width:number;&#125;//创建一个对象并指定泛型circle.color=&quot;red&quot;;//这里可以获取color属性circle.width=2;//有width属性 一个接口继承多个接口，创建多个接口的合成接口123456789101112131415interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface pen extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;pen&gt;&#123;&#125;; //创建一个对象并指定泛型square.color = &quot;blue&quot;;square.sideLength = 10; 混合类型所谓的混合类型就是在一个接口中定义多种类型，比如属性，函数，数组等： interface Counter { (start: number): string; interval: number; reset(): void; //没有返回值的函数 } function getCounter(): Counter { let counter = &lt;Counter&gt;function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0;]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>Interfaces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码解读之依赖收集]]></title>
    <url>%2F2019%2F01%2F19%2FVue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[通过上一篇Vue源码解读之响应式原理,我们可以看到Vue利用defineReactive会把普通的对象装换为响应式对象，在defineReactive函数中，重点是const dep = new Dep()，在设置getter的时候，收集依赖也就是dep.depend() 依赖收集 先看一下getter做的事情：访问对象属性的时候触发 12345678910111213141516171819202122232425262728293031 export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep()//在每个响应式键值的闭包中定义一个dep对象.......... Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; //拿到getter,没有getter就直接取val const value = getter ? getter.call(obj) : val //依赖收集的过程 Dep类：建立数据和watch之间的桥梁 if (Dep.target) &#123; dep.depend() // 进行收集依赖 if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value //最终返回value &#125;, // ... &#125;)&#125; 在getter 的时候进行依赖的收集，只有在 Dep.target 中有值的时候才会进行依赖收集； 这个 Dep.target 是在Watcher实例的 get 方法调用的时候 pushTarget 会把当前取值的watcher推入 Dep.target，原先的watcher压栈到 targetStack 栈中，当前取值的watcher取值结束后出栈并把原先的watcher值赋给 Dep.target，cleanupDeps 最后把新的 newDeps 里已经没有的watcher清空，以防止视图上已经不需要的无用watcher触发 DepDep 是整个 getter 依赖收集的核心，主要是建立数据和watcher之间的桥梁，主要是记录哪些Watcher依赖自己的变化，dep.depend()作用是在调用Dep.target的addDep（）函数。12345678910111213141516171819202122232425262728293031323334let uid = 0 、、Dep的实例ID，为了方便去重export default class Dep &#123; static target: ?Watcher;// 当前是谁在进行依赖收集 id: number; subs: Array&lt;Watcher&gt;; //所有的watcher集合 constructor () &#123; this.id = uid++ //Dep的实例id this.subs = [] //存储收集器中需要通知的watcher &#125; addSub(sub: Watcher) &#123; ... &#125; //添加一个观察者对象 removeSub(sub: Watcher) &#123; ... &#125; //移除一个观察者对象 depend () &#123;//依赖收集，当存在Dep.target的时候把自己添加观察者的依赖中 if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify() &#123; ... &#125; // 通知所有订阅者 &#125;&#125;Dep.target = nullconst targetStack = [] // watcher栈//将watcher观察者实例设置给Dep.target，用以依赖收集。同时将该实例存入target栈export function pushTarget (_target: ?Watcher) &#123; if (Dep.target) targetStack.push(Dep.target) Dep.target = _target&#125;//将观察者实例从target栈中取出并设置给Dep.target export function popTarget () &#123; Dep.target = targetStack.pop()&#125; Dep 是一个 Class，它定义了一些属性和方法，这里需要特别注意的是它有一个静态属性 target，这是一个全局唯一 Watcher，这是一个非常巧妙的设计，因为在同一时间只能有一个全局的 Watcher 被计算，另外它的自身属性 subs 也是 Watcher 的数组。它是Watcher的实例，用来通知更新。 watcher再来看一下watcher的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344export default class Watcher &#123; constructor( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean //是否是渲染watcher的标志位 ) &#123; this.getter = expOrFn // 在get方法中执行 if (this.computed) &#123; // 是否是 计算属性 this.value = undefined this.dep = new Dep()//计算属性创建过程中并未求值 &#125; else &#123; // 不是计算属性会立刻求值 this.value = this.get() &#125; &#125; /* 获得getter的值并且重新进行依赖收集 */ get() &#123; pushTarget(this) // 设置Dep.target = this let value value = this.getter.call(vm, vm) popTarget() // 将观察者实例从target栈中取出并设置给Dep.target this.cleanupDeps() return value &#125; addDep(dep: Dep)//添加一个依赖关系到Deps集合中 cleanupDeps() // 清理newDeps里没有的无用watcher依赖 update()// 调度者接口，当依赖发生改变的时候进行回调 run() // 调度者工作接口，将被调度者回调 getAndInvoke(cb: Function) &#123; ... &#125; evaluate() //收集该watcher的所有deps依赖 depend() // 收集该watcher的所有deps依赖，只有计算属性使用 teardown() // 将自身从所有依赖收集订阅列表删除&#125; 依赖收集流程当我们实例化一个渲染watcher的时候，执行this.get方法。进行get函数执行pushTarget()，实际上把Dep.target 赋值为当前的渲染 watcher 并压栈，接着执行value = this.getter.call(vm, vm)，实际上调用getter方法，触发数据的getter,从而调用dep.depend方法，也就会执行Dep.target.addDep(this):12345678910addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 此时会做一些逻辑判断（保证同一数据不会被添加多次）后执行 dep.addSub(this)，那么就会执行 this.subs.push(sub)，也就是说把当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs。]]></content>
      <categories>
        <category>Vue源码解读</category>
      </categories>
      <tags>
        <tag>watcher</tag>
        <tag>getter</tag>
        <tag>Dep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之变量声明]]></title>
    <url>%2F2019%2F01%2F18%2FTypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%8B%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[变量声明因为TypeScript是JavaScript的超集，所以它本身就支持let和const。const是对let的一个增强，它能阻止对一个变量再次赋值，在TS中，主要就是var let const,就简单说一下用法吧： var声明12345678910111213141516171819202122var a =10; //定义变量function f() &#123; //函数内部定义变量 var message = &quot;Hello, world!&quot;; return message;&#125;//函数嵌套调用function f() &#123; var a = 1; a = 2; var b = g(); a = 3; return b; function g() &#123; //g可以获取到f函数定义的a return a; &#125;&#125;f(); // returns 2 let声明let的声明与var一样，重要的是，let和var的区别是实现块级作用域，而且不存在变量提升，且不能重复赋值。 这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里12345678910111213141516//内部能访问到b,但是外部就不能访问； function f(input: boolean) &#123; let a = 100; if (input) &#123; // Still okay to reference &apos;a&apos; let b = a + 1; return b; &#125; // Error: &apos;b&apos; doesn&apos;t exist here return b;&#125;//暂时性死区的例子a++; // illegal to use &apos;a&apos; before it&apos;s declared;let a; 重复定义12let x = 10;let x = 20; // 错误，不能在1个作用域里多次声明`x` 并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。同样会发生错误12345678function f(x) &#123; let x = 100; // error: interferes with parameter declaration&#125;function g() &#123; let x = 100; var x = 100; // error: can&apos;t have both declarations of &apos;x&apos;&#125; 并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。1234567891011function f(condition, x) &#123; if (condition) &#123; let x = 100; return x; &#125; return x;&#125;f(false, 0); // returns 0f(true, 0); // returns 100 当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事。123for (let i = 0; i &lt; 10 ; i++) &#123; setTimeout(function() &#123;console.log(i); &#125;, 100 * i);&#125; //输出0-9 const声明const和let基本一致，只是const声明的变量被赋值后不能再改变（所以对于const来说，只声明不赋值，就会报错），作用域同let1234567891011121314151617const numLivesForCat = 9;const kitty = &#123; name: &quot;Aurora&quot;, numLives: numLivesForCat,&#125;// Errorkitty = &#123; name: &quot;Danielle&quot;, numLives: numLivesForCat&#125;;// all &quot;okay&quot;kitty.name = &quot;Rory&quot;;kitty.name = &quot;Kitty&quot;;kitty.name = &quot;Cat&quot;;kitty.numLives--; let vs. const使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。 解构解构(destructuring assignment)是一种表达式，将数组或者对象中的数据赋给另一变量。 数组解构1234let input = [1, 2,3];let [f, s] = input;console.log(f); // outputs 1console.log(s); // outputs 2 交换变量值123[f,s] = [s,f];console.log(f)； // outputs 2console.log(s); // outputs 1 使用…创建剩余变量1234let nums= [1,2,3,4]let [f, ...rest] = nums;console.log(f); // 输出： 1console.log(rest);// 输出： [2,3,4] 忽略数组中某些元素123let [first] = [1, 2, 3, 4];console.log(first); // 输出： 1let [, second, , fourth] = [1, 2, 3, 4]; 对象解构12345678let o = &#123; a: &quot;foo&quot;, b: 12, c: &quot;bar&quot;&#125;let &#123; a, b &#125; = o;console.log(a); // 输出： fooconsole.log(b);// 输出： 12 将对象o.a赋值给a,0.b赋值给b，这里的a,b都是对象属性名且必须一致，而属性c则会忽略 上述例子中声明的变量a和b必须和对象中属性一致，如果想换一个名字，写法如下：1234567891011let &#123; a: aa, b: bb &#125; = o;默认值let o = &#123; a: &quot;foo&quot;, b: undefined, c: &quot;bar&quot;&#125;let &#123;a, b=1&#125;= o;console.log(a); // 输出： fooconsole.log(b);// 输出： 1 当属性b的值为undefined时，解构表达式会使用默认值 展开展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 数组展开1234let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5];console.log(bpthPlus)；输出 [0,1,2,3,4,5] 对象展开1234let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123; ...defaults, food: &quot;rich&quot; &#125;;console.log(search); //输出：&#123;food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot;&#125; 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：123let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123;food: &quot;rich&quot;, ...defaults &#125;;console.log(search); //输出：&#123;food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot;&#125; 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：12345678910class C &#123; p = 12; m() &#123; &#125;&#125;let c = new C();let clone = &#123; ...c &#125;;clone.p; // okclone.m(); // error!]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>var</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>解构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之基本类型]]></title>
    <url>%2F2019%2F01%2F16%2FTypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript的类型分为原始数据类型和对象类型，原始数据类型主要包括：布尔值、数值、字符串、null、undefined 布尔值在TypeScript中，使用boolean定义布尔值类型1let do: boolean = true 使用构造函数Boolean创造的对象并不是布尔值12let createdByNewBoolean: boolean = new Boolean(1);// index.ts(1,5): error TS2322: Type &apos;Boolean&apos; is not assignable to type &apos;boolean&apos;. 因为 new Boolean()返回的是一个Boolean对象：1let createdByNewBoolean: boolean = new Boolean(1); 直接调用Boolean也可以返回一个boolean类型：1let createByBoolean:boolean = Boolean(1); 在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。 数值使用number定义的数值类型： 12345678let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity; 编译结果： 12345678var decLiteral = 6;var hexLiteral = 0xf00d;// ES6 中的二进制表示法var binaryLiteral = 10;// ES6 中的八进制表示法var octalLiteral = 484;var notANumber = NaN;var infinityNumber = Infinity; 字符串使用 string 定义字符串类型： 123456let myName: string = 'Tom';let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is $&#123;myName&#125;.I'll be $&#123;myAge + 1&#125; years old next month.`; 编译结果： 1234var myName = 'Tom';var myAge = 25;// 模板字符串var sentence = "Hello, my name is " + myName + ".\nI'll be " + (myAge + 1) + " years old next month."; 排列TypeScript与JavaScript一样，允许使用值数组。数组类型可以用两种方式之一编写。在第一个中，使用后跟[]元素的类型来表示该元素类型的数组：1let list: number[] = [1, 2, 3]; 另一种方式：使用通用数组类型Array1let list: Array&lt;number&gt; = [1, 2, 3]; 元组元组类型表示一个数组，其中已知固定数量的元素的类型，但不必相同。例如，您可能希望将值表示为a string和a 的对number：123456// Declare a tuple typelet x: [string, number];// Initialize itx = [&quot;hello&quot;, 10]; // OK// Initialize it incorrectlyx = [10, &quot;hello&quot;]; // Error 访问具有已知索引的元素时，将检索正确的类型：12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, &apos;number&apos; does not have &apos;substr&apos; 枚举默认情况下，枚举从开始编号开始编号0，可以手动设置其中一个成员的值来更改：12enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green; 枚举的一个便利功能是,可以从数值转到枚举中该值的名称。例如，如果我们有值，2但不确定在Color上面的枚举中映射到了什么，我们可以查找相应的名称：1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // Displays &apos;Green&apos; as its value is 2 abov 空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 123function warnUser(): void &#123; console.log("This is my warning message");&#125; 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; Null 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： 12let u: undefined = undefined;let n: null = null; undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12// 这样不会报错let num: number = undefined; 123// 这样也不会报错let u: undefined;let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量： 1234let u: void;let num: number = u;// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'. 任意值我们可能需要描述在编写应用程序时我们不知道的变量类型。这些值可能来自动态内容，例如来自用户或第三方库。在这些情况下，我们希望选择退出类型检查，并让值通过编译时检查。为此，我们使用以下any类型标记这些123let notSure: any = 4;notSure = "maybe a string instead";notSure = false; // okay, definitely a boolean 如果是一个普通类型，在赋值过程中改变类型是不被允许的： 1234let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 但如果是 any 类型，则允许被赋值为任意类型。 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 在任意值上访问任何属性都是允许的： 123let anyThing: any = 'hello';console.log(anyThing.myName);console.log(anyThing.myName.firstName); 也允许调用任何方法： 1234let anyThing: any = 'Tom';anyThing.setName('Jerry');anyThing.setName('Jerry').sayHello();anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： 12345let something;something = 'seven';something = 7;something.setName('Tom'); 等价于 12345let something: any;something = 'seven';something = 7;something.setName('Tom');]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之初入TypeScript]]></title>
    <url>%2F2019%2F01%2F16%2FTypeScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%9D%E5%85%A5TypeScript%2F</url>
    <content type="text"><![CDATA[what?TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript；主要提供类型系统和对ES6的支持；免费开源。 官网：http://www.typescriptlang.org/ why？优势 增加代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了；可以在编译阶段就发现大部分错误，这总比在运行时候出错好；增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。 非常包容 TypeScript 是JavaScript的超集，.js文件可以直接重命名为 .ts 即可；即使不显式的定义类型，也能够自动做出类型推论；可以定义从简单到复杂的几乎一切类型；即使TypeScript 编译报错，也可以生成 JavaScript 文件；兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 拥有活跃的社区 优势 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量安装TypeScript 的命令行工具安装方法如下： 1npm install -g typescript 以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。 编译一个 TypeScript 文件很简单： 1tsc hello.ts 我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。 编辑器TypeScript 最大的优势便是增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。 主流的编辑器都支持 TypeScript，这里我推荐使用Sublime Text 其他编辑器或 IDE 对 TypeScript 的支持： Visual Studio Code Atom WebStorm Vim Emacs Eclipse Visual Studio 2015 Visual Studio 2013 Hello TypeScript我们从一个简单的例子开始。 将以下代码复制到 hello.ts 中： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = 'Tom';console.log(sayHello(user)); 然后执行 1tsc hello.ts 这时候会生成一个编译好的文件 hello.js： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = 'Tom';console.log(sayHello(user)); TypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以。 上述例子中，我们用 : 指定 person 参数类型为 string。但是编译为 js 之后，并没有什么检查的代码被插入进来。 TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。 let 是 ES6 中的关键字，和 var 类似，用于定义一个局部变量，可以参阅 let 和 const 命令。 下面尝试把这段代码编译一下： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = [0, 1, 2];console.log(sayHello(user)); 编辑器中会提示错误，编译的时候也会出错： 1index.ts(6,22): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'. 但是还是生成了 js 文件： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = [0, 1, 2];console.log(sayHello(user)); TypeScript 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件。 如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json，请参阅官方手册（中文版）。]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码解读之响应式原理]]></title>
    <url>%2F2019%2F01%2F12%2FVue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[相信用过Vue的基本上都知道Vue的响应式都是利用了Object.defineProperty。当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 Object.definePropertyObject.defineProperty 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法： Object.defineProperty(obj, prop, descriptor) obj 是要在其上定义属性的对象；prop 是要定义或修改的属性的名称；descriptor 是将被定义或修改的属性描述符。这里我们最关心的是 get 和 set，get 是一个给属性提供的 getter 方法，当我们访问了该属性的时候会触发 getter 方法；set 是一个给属性提供的 setter 方法，当我们对该属性做修改的时候会触发 setter 方法。一旦对象拥有了 getter 和 setter，我们可以简单地把这个对象称为响应式对象。 observeobserve 的功能就是用来监测数据的变化 123456789101112131415161718192021export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; // 数组 对象 还是可扩展的 Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) //满足之后调用Observer &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; ObserverObserver 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新： /** * Observer class that is attached to each observed * object. Once attached, the observer converts the target * object&apos;s property keys into getter/setters that * collect dependencies and dispatch updates. */ export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 def(value, &apos;__ob__&apos;, this) // 手机依赖 第四个参数没有传递 if (Array.isArray(value)) { 是否为数组 const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) this.observeArray(value) // 遍历数组的每个元素 } else { this.walk(value) 不是数组执行walk } } /** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { //遍历对象的所有属性 调用defineProperty的方法 遍历keys const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineProperty(obj, keys[i]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } } } Observer 的构造函数逻辑很简单，首先实例化 Dep 对象，接着通过执行 def 函数把自身实例添加到数据对象 value 的 ob 属性上，def 的定义在 src/core/util/lang.js 中： // 对defineProperty的一个封装 export function def (obj: Object, key: string, val: any, enumerable?: boolean) { Object.defineProperty(obj, key, { value: val, enumerable: !!enumerable, // 不可枚举的 传入的是undefined writable: true, configurable: true }) } def 函数是一个非常简单的Object.defineProperty 的封装，这就是为什么在开发中输出 data 上对象类型的数据，会发现该对象多了一个 ob 的属性。 回到 Observer 的构造函数，接下来会对 value 做判断，对于数组会调用 observeArray 方法，否则对纯对象调用 walk 方法。可以看到 observeArray 是遍历数组再次调用 observe 方法，而 walk 方法是遍历对象的 key 调用 defineReactive 方法 defineReactivedefineReactive 的功能就是定义一个响应式对象，给对象动态添加 getter 和 sette /** * Define a reactive property on an Object. */ export function defineReactive ( //接收五个参数 obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean ) { const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) //对象属性的定义 if (property &amp;&amp; property.configurable === false) { // false就什么都不做 return } // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) { // walk的时候 对key求值赋给val val = obj[key] } let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { //访问的时候触发 并依赖收集 const value = getter ? getter.call(obj) : val if (Dep.target) { dep.depend() if (childOb) { childOb.dep.depend() if (Array.isArray(value)) { dependArray(value) } } } return value }, set: function reactiveSetter (newVal) { // 修改触发 并派发更新 const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) { customSetter() } if (setter) { setter.call(obj, newVal) } else { val = newVal } childOb = !shallow &amp;&amp; observe(newVal) dep.notify() } }) } defineReactive 函数最开始初始化 Dep 对象的实例，接着拿到 obj 的属性描述符，然后对子对象递归调用 observe 方法，这样就保证了无论 obj 的结构多复杂，它的所有子属性也能变成响应式的对象，这样我们访问或修改 obj 中一个嵌套较深的属性，也能触发 getter 和 setter。最后利用 Object.defineProperty 去给 obj 的属性 key 添加 getter 和 setter。 总结响应式对象，核心就是利用 Object.defineProperty 给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新。后面会根据依赖收集进行一个解读。]]></content>
      <categories>
        <category>Vue源码解读</category>
      </categories>
      <tags>
        <tag>watcher</tag>
        <tag>getter</tag>
        <tag>setter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码解读之数据绑定]]></title>
    <url>%2F2019%2F01%2F08%2FVue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[从最开始vue初始化到渲染的整个流程如下：new Vue—-一系列的初始化—-$mount做挂载—如果是带编译的版本就compile,没有就跳过—render函数—生成vnode—patch方法—渲染成DOM,如下图： 何为数据驱动数据驱动就是指视图由数据来生成，在传统的前端开发中，大多是利用jQuery直接对DOM进行修改，而在Vue开发中，对视图的修改，不会直接操作DOM，而是通过修改数据来实现。当交互较为复杂的时候，我们只需要关心数据，所有的逻辑都是通过对DOM的修改实现，而不用接触DOM，这样不仅仅简化代码，让代码逻辑更为清晰也有利于代码的维护。 new Vue的实际过程从入口代码开始分析，我们先来分析 new Vue 背后发生了哪些事情。我们都知道，new 关键字在 Javascript 语言中代表实例化是一个对象，而 Vue 实际上是一个类，类在 Javascript 中是用 Function 来实现的，来看一下源码，在src/core/instance/index.js 中。 function Vue (options) { if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue) ) { warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) } this._init(options) } 可以看到 Vue 只能通过 new 关键字初始化，然后会调用 this._init 方法 Vue.prototype._init = function (options?: Object) { //挂载在原型上的init方法 const vm: Component = this ......... // merge options 合并options if (options &amp;&amp; options._isComponent) { // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ) } ....... // expose real self 一系列的初始化 vm._self = vm initLifecycle(vm) //生命周期初始化 initEvents(vm) // 事件 initRender(vm) callHook(vm, &apos;beforeCreate&apos;) initInjections(vm) // resolve injections before data/props initState(vm) //对data。props等的初始化，最终通过poxy(vm,&apos;_data;,key)代理挂载到vm上 initProvide(vm) // resolve provide after data/props callHook(vm, &apos;created&apos;) /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) { vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue ${vm._name} init`, startTag, endTag) } if (vm.$options.el) { //判断有没有el 如果有 vm.$mount(vm.$options.el) //通过$mount做挂载 目的就是把模板渲染成最终的DOM } } Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。 Vue 实例挂载的实现Vue 中我们是通过 $mount 实例方法去挂载 vm 的，先来看一下 src/platform/web/entry-runtime-with-compiler.js 文件中定义： const mount = Vue.prototype.$mount Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el &amp;&amp; query(el) //如果el为bady或者element 报警告 vue不可直接挂载在bady或者element 会直接覆盖 if (el === document.body || el === document.documentElement) { process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this } const options = this.$options // resolve template/el and convert to render function if (!options.render) { //是否定义render方法 let template = options.template if (template) { //是否定义render方法 if (typeof template === &apos;string&apos;) { if (template.charAt(0) === &apos;#&apos;) { template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !template) { warn( `Template element not found or is empty: ${options.template}`, this ) } } } else if (template.nodeType) { template = template.innerHTML } else { if (process.env.NODE_ENV !== &apos;production&apos;) { warn(&apos;invalid template option:&apos; + template, this) } return this } } else if (el) { template = getOuterHTML(el) //拿到对象的outerhtml } if (template) { /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) { mark(&apos;compile&apos;) } // 编译相关的内容，会转换为rander函数 const { render, staticRenderFns } = compileToFunctions(template, { shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments }, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) { mark(&apos;compile end&apos;) measure(`vue ${this._name} compile`, &apos;compile&apos;, &apos;compile end&apos;) } } } return mount.call(this, el, hydrating) //原型上的mount方法 } 这段代码首先缓存了原型上的 $mount 方法，再重新定义该方法。首先，它对 el 做了限制，Vue 不能挂载在 body、html 这样的根节点上。接下来的是很关键的逻辑 —— 如果没有定义 render 方法，则会把 el 或者 template 字符串转换成 render 方法。这里我们要牢记，在 Vue 2.0 版本中，所有 Vue 的组件的渲染最终都需要 render 方法，无论我们是用单文件 .vue 方式开发组件，还是写了 el 或者 template 属性，最终都会转换成 render 方法，那么这个过程是 Vue 的一个“在线编译”的过程，它是调用 compileToFunctions 方法实现的，编译过程我们之后会介绍。最后，调用原先原型上的 $mount 方法挂载。 // public mount method Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating) } $mount 方法支持传入 2 个参数，第一个是 el，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象的。第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 src/core/instance/lifecycle.js 文件中： export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean ): Component { vm.$el = el // 做一个缓存 if (!vm.$options.render) { // 如果没有render 创建一个VNode vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== &apos;production&apos;) { /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &apos;#&apos;) || vm.$options.el || el) { // 用了template 用了runtime版本； warn( &apos;You are using the runtime-only build of Vue where the template &apos; + &apos;compiler is not available. Either pre-compile the templates into &apos; + &apos;render functions, or use the compiler-included build.&apos;, vm ) } else { warn( &apos;Failed to mount component: template or render function not defined.&apos;, //没有template和render函数 vm ) } } } callHook(vm, &apos;beforeMount&apos;) let updateComponent /* istanbul ignore if */ 开发环境又配置了performance 的时候 if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) { updateComponent = () =&gt; { const name = vm._name const id = vm._uid const startTag = `vue-perf-start:${id}` const endTag = `vue-perf-end:${id}` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue ${name} render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue ${name} patch`, startTag, endTag) } } else { updateComponent = () =&gt; { // 渲染方法 监听到执行的过程，修改的时候也是触发这个方法 vm._update(vm._render(), hydrating) //执行vm._render(), vm._update(） } } // we set this to vm._watcher inside the watcher&apos;s constructor // since the watcher&apos;s initial patch may call $forceUpdate (e.g. inside child // component&apos;s mounted hook), which relies on vm._watcher being already defined // 渲染watcher watcher也是一个类 noop是空函数 new Watcher(vm, updateComponent, noop, { before () { if (vm._isMounted) { callHook(vm, &apos;beforeUpdate&apos;) } } }, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, &apos;mounted&apos;) } return vm } 从上面的代码可以看到，mountComponent 核心就是先调用 vm._render 方法先生成虚拟 Node，再实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法，最终调用 vm._update 更新 DOM。Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数函数最后判断为根节点的时候设置 vm._isMounted 为 true， 表示这个实例已经挂载了，同时执行 mounted 钩子函数。 这里注意 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。 vm_render()Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中： Vue.prototype._render = function (): VNode { const vm: Component = this const { render, _parentVnode } = vm.$options // reset _rendered flag on slots for duplicate slot check if (process.env.NODE_ENV !== &apos;production&apos;) { for (const key in vm.$slots) { // $flow-disable-line vm.$slots[key]._rendered = false } } if (_parentVnode) { vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject } // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try { vnode = render.call(vm._renderProxy, vm.$createElement) //vm._renderProxy其实就是vm本身 } catch (e) { handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &apos;production&apos;) { if (vm.$options.renderError) { try { vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) } catch (e) { handleError(e, vm, `renderError`) vnode = vm._vnode } } else { vnode = vm._vnode } } else { vnode = vm._vnode } } // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) { if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; Array.isArray(vnode)) { warn( &apos;Multiple root nodes returned from render function. Render function &apos; + &apos;should return a single root node.&apos;, vm ) } vnode = createEmptyVNode() } // set parent vnode.parent = _parentVnode return vnode } 这段代码最关键的是 render 方法的调用，我们在平时的开发工作中手写 render 方法的场景比较少，而写的比较多的是 template 模板，在之前的 mounted 方法的实现中，会把 template 编译成 render 方法在 Vue 的官方文档中介绍了 render 函数的第一个参数是 createElement，那么结合之前的例子： &lt;div id=&quot;app&quot;&gt; {{ message }} &lt;/div&gt; 相当于我们编写如下 render 函数： render: function (createElement) { return createElement(&apos;div&apos;, { attrs: { id: &apos;app&apos; }, }, this.message) } 再回到 _render 函数中的 render 方法的调用： vnode = render.call(vm._renderProxy, vm.$createElement) 可以看到，render 函数中的 createElement 方法就是 vm.$createElement 方法： export function initRender (vm: Component) { vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) } 实际上，vm.$createElement 方法定义是在执行 initRender 方法的时候，可以看到除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。 Virtual DOMVirtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。当我们频繁的去做 DOM 更新，会产生一定的性能问题。所以它比创建一个 DOM 的代价要小很多。在 Vue.js 中，Virtual DOM 是用 VNode 这么一个 Class 去描述，它是定义在 src/core/vdom/vnode.js 中的。 export default class VNode { tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component&apos;s scope key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node ....... 可以看到 Vue.js 中的 Virtual DOM 的定义还是略微复杂一些的，因为它这里包含了很多 Vue.js 的特性。其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义标签名、数据、子节点、键值等，其它属性都是都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。 createElementVue.js 利用 createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 中： export function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean ): VNode | Array&lt;VNode&gt; { if (Array.isArray(data) || isPrimitive(data)) { // 对参数个数不一致的处理 normalizationType = children children = data data = undefined } if (isTrue(alwaysNormalize)) { normalizationType = ALWAYS_NORMALIZE } return _createElement(context, tag, data, children, normalizationType) } createElement 方法实际上是对 _createElement 方法的封装，它允许传入的参数更加灵活，在处理这些参数后，调用真正创建 VNode 的函数 _createElement： export function _createElement ( //五个参数 context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number ): VNode | Array&lt;VNode&gt; { if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) { //对data做校验 data不能是响应式 process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn( `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` + &apos;Always create fresh vnode data objects in each render!&apos;, context ) return createEmptyVNode() // 相当于一个注释结点 } // object syntax in v-bind if (isDef(data) &amp;&amp; isDef(data.is)) { 判断data.is 做相应的处理 tag = data.is } if (!tag) { // in case of component :is set to falsy value return createEmptyVNode() // 不是真值 返回注释结点 } // warn against non-primitive key 对key的一个判断 .......... } if (normalizationType === ALWAYS_NORMALIZE) { children = normalizeChildren(children) // 如果其中一个子节点为array 递归 } else if (normalizationType === SIMPLE_NORMALIZE) { children = simpleNormalizeChildren(children) //对children做遍历 是一个一维数组 数组每一个都是一个vnode } let vnode, ns if (typeof tag === &apos;string&apos;) { // tag为一个string let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) { // platform built-in elements vnode = new VNode( // 创建一个vnode config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) } else if (isDef(Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) { // component 组件的解析 vnode = createComponent(Ctor, data, context, children, tag) } else { // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) } } else { // direct component options / constructor vnode = createComponent(tag, data, context, children) } if (Array.isArray(vnode)) { return vnode } else if (isDef(vnode)) { if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode } else { return createEmptyVNode() } } _createElement 方法有 5 个参数，context 表示 VNode 的上下文环境，它是 Component 类型；tag 表示标签，它可以是一个字符串，也可以是一个 Component；data 表示 VNode 的数据，它是一个 VNodeData 类型；children 表示当前 VNode 的子节点，它是任意类型的，它接下来需要被规范为标准的 VNode 数组；normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，它主要是参考 render 函数是编译生成的还是用户手写的。createElement 函数的流程略微有点多，我们接下来主要分析 2 个重点的流程 —— children 的规范化以及 VNode 的创建。 children 的规范化由于 Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型。_createElement 接收的第 4 个参数 children 是任意类型的，因此我们需要把它们规范成 VNode 类型。这里根据 normalizationType 的不同，调用了 normalizeChildren(children) 和 simpleNormalizeChildren(children) 方法，它们的定义都在 src/core/vdom/helpers/normalzie-children.js 中： // 1. When the children contains components - because a functional component // may return an Array instead of a single root. In this case, just a simple // normalization is needed - if any child is an Array, we flatten the whole // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep // because functional components already normalize their own children. export function simpleNormalizeChildren (children: any) { for (let i = 0; i &lt; children.length; i++) { if (Array.isArray(children[i])) { return Array.prototype.concat.apply([], children) } } return children } // 2. When the children contains constructs that always generated nested Arrays, // e.g. &lt;template&gt;, &lt;slot&gt;, v-for, or when the children is provided by user // with hand-written render functions / JSX. In such cases a full normalization // is needed to cater to all possible types of children values. export function normalizeChildren (children: any): ?Array&lt;VNode&gt; { return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined } simpleNormalizeChildren 方法调用场景是 render 函数当函数是编译生成的。理论上编译生成的 children 都已经是 VNode 类型的，但这里有一个例外，就是 functional component 函数式组件返回的是一个数组而不是一个根节点，所以会通过 Array.prototype.concat 方法把整个 children 数组打平，让它的深度只有一层。normalizeChildren 方法的调用场景有 2 种，一个场景是 render 函数是用户手写的，当 children 只有一个节点的时候，Vue.js 从接口层面允许用户把 children 写成基础类型用来创建单个简单的文本节点，这种情况会调用 createTextVNode 创建一个文本节点的 VNode；另一个场景是当编译 slot、v-for 的时候会产生嵌套数组的情况，会调用 normalizeArrayChildren 方法，接下来看一下它的实现： function normalizeArrayChildren (children: any, nestedIndex?: string): Array&lt;VNode&gt; { const res = [] let i, c, lastIndex, last for (i = 0; i &lt; children.length; i++) { c = children[i] if (isUndef(c) || typeof c === &apos;boolean&apos;) continue lastIndex = res.length - 1 last = res[lastIndex] // nested if (Array.isArray(c)) { if (c.length &gt; 0) { c = normalizeArrayChildren(c, `${nestedIndex || &apos;&apos;}_${i}`) // merge adjacent text nodes if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) { res[lastIndex] = createTextVNode(last.text + (c[0]: any).text) c.shift() } res.push.apply(res, c) } } else if (isPrimitive(c)) { if (isTextNode(last)) { // merge adjacent text nodes // this is necessary for SSR hydration because text nodes are // essentially merged when rendered to HTML strings res[lastIndex] = createTextVNode(last.text + c) } else if (c !== &apos;&apos;) { // convert primitive to vnode res.push(createTextVNode(c)) } } else { if (isTextNode(c) &amp;&amp; isTextNode(last)) { // merge adjacent text nodes res[lastIndex] = createTextVNode(last.text + c.text) } else { // default key for nested array children (likely generated by v-for) if (isTrue(children._isVList) &amp;&amp; isDef(c.tag) &amp;&amp; isUndef(c.key) &amp;&amp; isDef(nestedIndex)) { c.key = `__vlist${nestedIndex}_${i}__` } res.push(c) } } } return res } normalizeArrayChildren 接收 2 个参数，children 表示要规范的子节点，nestedIndex 表示嵌套的索引，因为单个 child 可能是一个数组类型。 normalizeArrayChildren 主要的逻辑就是遍历 children，获得单个节点 c，然后对 c 的类型判断，如果是一个数组类型，则递归调用 normalizeArrayChildren; 如果是基础类型，则通过 createTextVNode 方法转换成 VNode 类型；否则就已经是 VNode 类型了，如果 children 是一个列表并且列表还存在嵌套的情况，则根据 nestedIndex 去更新它的 key。这里需要注意一点，在遍历的过程中，对这 3 种情况都做了如下处理：如果存在两个连续的 text 节点，会把它们合并成一个 text 节点。经过对 children 的规范化，children 变成了一个类型为 VNode 的 Array。 vnode 创建回到 createElement 函数，规范化 children 后，接下来会去创建一个 VNode 的实例： let vnode, ns if (typeof tag === &apos;string&apos;) { let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) { // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) } else if (isDef(Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) { // component vnode = createComponent(Ctor, data, context, children, tag) } else { // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) } } else { // direct component options / constructor vnode = createComponent(tag, data, context, children) } 这里先对 tag 做判断，如果是 string 类型，则接着判断如果是内置的一些节点，则直接创建一个普通 VNode，如果是为已注册的组件名，则通过 createComponent 创建一个组件类型的 VNode，否则创建一个未知的标签的 VNode。 如果是 tag 一个 Component 类型，则直接调用 createComponent 创建一个组件类型的 VNode 节点。对于 createComponent 创建组件类型的 VNode 的过程，我们之后会去介绍，本质上它还是返回了一个 VNode。那么至此，我们大致了解了 createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要把这个 VNode 渲染成一个真实的 DOM 并渲染出来，这个过程是通过 vm._update 完成的。 vm_updateVue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候。_update 方法的作用是把 VNode 渲染成真实的 DOM Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) { // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) } else { // updates vm.$el = vm.__patch__(prevVnode, vnode) } activeInstance = prevActiveInstance // update __vue__ reference if (prevEl) { prevEl.__vue__ = null } if (vm.$el) { vm.$el.__vue__ = vm } // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el } // updated hook is called by the scheduler to ensure that children are // updated in a parent&apos;s updated hook. } _update 的核心就是调用 vm.patch 方法，它的定义在 src/platforms/web/runtime/patch.js中： export const patch: Function = createPatchFunction({ nodeOps, modules }) 该方法的定义是调用 createPatchFunction 方法的返回值，这里传入了一个对象，包含 nodeOps 参数和 modules 参数。其中，nodeOps 封装了一系列 DOM 操作的方法，modules 定义了一些模块的钩子函数的实现。createPatchFunction 内部定义了一系列的辅助方法，最终返回了一个 patch 方法，这个方法就赋值给了 vm._update 函数里调用的 vm.patch，它接收 4个参数，oldVnode 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；vnode 表示执行 _render 后返回的 VNode 的节点；hydrating 表示是否是服务端渲染；removeOnly 是给 transition-group 用的，patch 的逻辑看上去相对复杂确定了这些入参后，我们回到 patch 函数的执行过程，看几个关键步骤。 const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) { // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) } else { if (isRealElement) { // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.removeAttribute(SSR_ATTR) hydrating = true } if (isTrue(hydrating)) { if (hydrate(oldVnode, vnode, insertedVnodeQueue)) { invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode } else if (process.env.NODE_ENV !== &apos;production&apos;) { warn( &apos;The client-side rendered virtual DOM tree is not matching &apos; + &apos;server-rendered content. This is likely caused by incorrect &apos; + &apos;HTML markup, for example nesting block-level elements inside &apos; + &apos;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &apos; + &apos;full client-side render.&apos; ) } } // either not server-rendered, or hydration failed. // create an empty node and replace it oldVnode = emptyNodeAt(oldVnode) } // replacing existing element const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // create new node 创建新结点 createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) } 由于我们传入的 oldVnode 实际上是一个 DOM container，所以 isRealElement 为 true，接下来又通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象，然后再调用 createElm 方法，这个方法在这里非常重要，来看一下它的实现： function createElm ( vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index ) { if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) { // This vnode was used in a previous render! // now it&apos;s used as a new node, overwriting its elm would cause // potential patch errors down the road when it&apos;s used as an insertion // reference node. Instead, we clone the node on-demand before creating // associated DOM element for it. vnode = ownerArray[index] = cloneVNode(vnode) } vnode.isRootInsert = !nested // for transition enter check 创建子组件 if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) { return } const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) { if (process.env.NODE_ENV !== &apos;production&apos;) { if (data &amp;&amp; data.pre) { creatingElmInVPre++ } if (isUnknownElement(vnode, creatingElmInVPre)) { warn( &apos;Unknown custom element: &lt;&apos; + tag + &apos;&gt; - did you &apos; + &apos;register the component correctly? For recursive components, &apos; + &apos;make sure to provide the &quot;name&quot; option.&apos;, vnode.context ) } } vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode) setScope(vnode) /* istanbul ignore if */ if (__WEEX__) { // ... } else { createChildren(vnode, children, insertedVnodeQueue) if (isDef(data)) { invokeCreateHooks(vnode, insertedVnodeQueue) } insert(parentElm, vnode.elm, refElm) } if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; data &amp;&amp; data.pre) { creatingElmInVPre-- } } else if (isTrue(vnode.isComment)) { vnode.elm = nodeOps.createComment(vnode.text) insert(parentElm, vnode.elm, refElm) } else { vnode.elm = nodeOps.createTextNode(vnode.text) insert(parentElm, vnode.elm, refElm) } } createElm 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。 我们来看一下它的一些关键逻辑，createComponent 方法目的是尝试创建子组件，在当前这个 case 下它的返回值为 false；接下来判断 vnode 是否包含 tag，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；然后再去调用平台 DOM 的操作去创建一个占位符元素。接下来调用 createChildren 方法去创建子元素： createChildren(vnode, children, insertedVnodeQueue) function createChildren (vnode, children, insertedVnodeQueue) { if (Array.isArray(children)) { if (process.env.NODE_ENV !== &apos;production&apos;) { checkDuplicateKeys(children) } for (let i = 0; i &lt; children.length; ++i) { createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i) } } else if (isPrimitive(vnode.text)) { nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text))) } } createChildren 的逻辑很简单，实际上是遍历子虚拟节点，递归调用 createElm，这里要注意的一点是在遍历过程中会把 vnode.elm 作为父容器的 DOM 节点占位符传入。 接着再调用 invokeCreateHooks 方法执行所有的 create 的钩子并把 vnode push 到 insertedVnodeQueue 中。 if (isDef(data)) { invokeCreateHooks(vnode, insertedVnodeQueue) } function invokeCreateHooks (vnode, insertedVnodeQueue) { for (let i = 0; i &lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, vnode) } i = vnode.data.hook // Reuse variable if (isDef(i)) { if (isDef(i.create)) i.create(emptyNode, vnode) if (isDef(i.insert)) insertedVnodeQueue.push(vnode) } } 最后调用 insert 方法把 DOM 插入到父节点中，因为是递归调用，子元素会优先调用 insert，所以整个 vnode 树节点的插入顺序是先子后父。来看一下 insert 方法，它的定义在 src/core/vdom/patch.js 上。 insert(parentElm, vnode.elm, refElm) function insert (parent, elm, ref) { if (isDef(parent)) { if (isDef(ref)) { if (ref.parentNode === parent) { nodeOps.insertBefore(parent, elm, ref) } } else { nodeOps.appendChild(parent, elm) } } } insert 逻辑很简单，调用一些 nodeOps 把子节点插入到父节点中，这些辅助方法定义在 src/platforms/web/runtime/node-ops.js 中： export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) { parentNode.insertBefore(newNode, referenceNode) } export function appendChild (node: Node, child: Node) { node.appendChild(child) } 其实就是调用原生 DOM 的 API 进行 DOM 操作，在 createElm 过程中，如果 vnode 节点不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。首次渲染我们调用了 createElm 方法，这里传入的 parentElm 是 oldVnode.elm 的父元素，在我们的例子是 id 为 #app div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。嗯，终于大概对着学习文档理了一遍。有点简陋，可能很多细节没有注意到]]></content>
      <categories>
        <category>Vue源码解读</category>
      </categories>
      <tags>
        <tag>render</tag>
        <tag>Virtual DOM</tag>
        <tag>createElement</tag>
        <tag>update</tag>
        <tag>patch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码解读之基础前言]]></title>
    <url>%2F2019%2F01%2F05%2FVue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言从开始学习Vue到现在也有1年半了吧，以后的工作也是大部分的Vue相关，为了打好基础，方便迎接年后Vue3.0，给自己定了一个计划-有针对性的读源码并做一个系列的总结。 Flow静态检测Vue.js 的源码利用了 Flow 做了静态类型检查，所以要对flow有一定的了解诶啊在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下： flow ├── compiler.js # 编译相关 ├── component.js # 组件数据结构 ├── global-api.js # Global API 结构 ├── modules.js # 第三方库定义 ├── options.js # 选项相关 ├── ssr.js # 服务端渲染相关 ├── vnode.js # 虚拟 node 相关 Vue源码目录在git上下载Vue的源码，可以看到src的子目录如下： src ├── compiler # 编译相关 ├── core # 核心代码 ├── platforms # 不同平台的支持，有web+weex ├── server # 服务端渲染 ├── sfc # .vue 文件解析 ├── shared # 共享代码 Vue源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件，它的内容实际上是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下： { &quot;script&quot;: { &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;build:ssr&quot;: &quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;, &quot;build:weex&quot;: &quot;npm run build --weex&quot; } } 先打开构建的入口 JS 文件，在 scripts/build.js 中：这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。1234567891011121314let builds = require(&apos;./config&apos;).getAllBuilds()// filter builds via command line argif (process.argv[2]) &#123; const filters = process.argv[2].split(&apos;,&apos;) builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf(&apos;weex&apos;) === -1 &#125;)&#125;build(builds) Vue入口import Vue from ‘./runtime/index’ 定义Vue的入口，那Vue是如何被定义的呢？123import Vue from &apos;core/index&apos; //重点！重点引入代码.........export default Vue 在core中的index代码如下：123456789import Vue from &apos;./instance/index&apos; //重点 引入Vue定义代码import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;initGlobalAPI(Vue) // 重点！！1！初始化全局的APIObject.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123; get: isServerRendering&#125;)........export default Vue Vue 的真实定义：终于看到了 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。 import { initMixin } from &apos;./init&apos; import { stateMixin } from &apos;./state&apos; import { renderMixin } from &apos;./render&apos; import { eventsMixin } from &apos;./events&apos; import { lifecycleMixin } from &apos;./lifecycle&apos; import { warn } from &apos;../util/index&apos; function Vue (options) { if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue) ) { warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) } this._init(options) } initMixin(Vue) stateMixin(Vue) eventsMixin(Vue) lifecycleMixin(Vue) renderMixin(Vue) export default Vue initGlobalAPI：Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中： 123456789101112131415161718192021222324252627282930313233export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== &apos;production&apos;) &#123; configDef.set = () =&gt; &#123; warn( &apos;Do not replace the Vue.config object, set individual fields instead.&apos; ) &#125; &#125; Object.defineProperty(Vue, &apos;config&apos;, configDef) Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &apos;s&apos;] = Object.create(null) &#125;) Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue)&#125;]]></content>
      <categories>
        <category>Vue源码解读</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码，Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像格式的区别以及应用场景]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[在实际的开发中，遇到了这个问题，有点理不清，特来整理一次： jpg格式全名应该是JPEG。JPEG 图片以 24 位颜色存储单个光栅图像。JPEG 是与平台无关的格式，支持最高级别的压缩，不过，这种压缩是有损耗的。渐近式JPEG文件支持交错。可以提高或降低 JPEG文件压缩的级别。但是，文件大小是以图像质量为代价的。压缩比率可以高达 100:1。（JPEG 格式可在 10:1 到 20:1 的比率下轻松地压缩文件，而图片质量不会下降。）JPEG压缩可以很好地处理写实摄影作品。但是，对于颜色较少、对比级别强烈、实心边框或纯色区域大的较简单的作品，JPEG 压缩无法提供理想的结果。有时，压缩比率会低到5:1，严重损失了图片完整性。这一损失产生的原因是，JPEG 压缩方案可以很好地压缩类似的色调，但是 JPEG 压缩方案不能很好地处理亮度的强烈差异或处理纯色区域。Jpeg格式特点： 透明性：它不支持透明性 动画：它不支持动画 损耗性：除了一些比如说（仅仅是90、180、270度旋转），裁切，从标准类型到先进类型，编辑图片的原数据之外，所有其它操作对jpeg图像的处理都会使得它的质量损失，所以我们在编辑过程一般用png作为过渡格式。 隔行渐进显示，它支持隔行渐进显示（但是ie浏览器并不支持这个属性，但是ie会在整个图像信息完全达到的时候显示）。由上可以看出Jpeg是最适web上面的摄影图片和数字照相机中。根据惊叹我们在页面中使用的商品图片、采用人像或者好、实物素材制作的广告更适合采用JPG格式保存。gif格式GIF(GraphicsInterchange Format)的原义是“图像互换格式”，是CompuServe公司在 1987年开发的图像文件格式。GIF文件的数据，是一种基于LZW算法的连续色调的无损压缩格式。其压缩率一般在50％左右，它不属于任何应用程序。目前几乎所有相关软件都支持它，公共领域有大量的软件在使用GIF图像文件。GIF图像文件的数据是经过压缩的，而且是采用了可变长度等压缩算法。所以GIF的图像深度从lbit到8bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。gif 格式特点： 透明性：gif是一种布尔透明类型，即它可以使全透明，也可是全不透明，但是它并没有半透明的（alpha透明）。 动画：gif格式支持动画。 无损耗性：gif是一种无损耗的图像格式，这也意味着你可以对gif图片做任何操作也不会使得图像质量产生损耗。 水平扫描：gif是使用一种叫做LZW的算法进行压缩的，当压缩gif的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的gif图片比竖向的gif更加小。例如50010的图片比10500的图片更加小。 间隔渐进显示：gif支持可选择性的间隔渐进显示。由以上特点看出只有256种颜色的gif图片不适合照片，但它适合对颜色要求不高的图形（比如说图标、图表等）。png格式PNG是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。流式网络图形格式(Portable Network Graphic Format，PNG)名称来源于非官方的“PNG’s NotGIF”，是一种位图文件(bitmapfile)存储格式，读成“ping”。PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据。PNG使用从LZ77派生的无损数据压缩算法Png格式特点： 类型：Png这种图片格式包括了许多类，但是在实践的大致中可以分为256色的png和全色的png，你完全可以用256色的png代替gif，用全色的png代替jpeg。 透明性：png是完全支持alpha透明的（透明、半透明、不透明），尽管有两个怪异的现象在ie6（下面详细讨论） 动画：它不支持动画Png8的在ie中的怪异表现：半透明的png8在ie6以下的浏览器显示为全透明。alpha透明的全色PNG（png32）在ie6中会出现背景颜色（通常是灰色）上面可以总结：全透明的png8可以在任一浏览器正常显示（就像gif一样）。半透明的png8在除了ie6及其一下的浏览器下错误的显示成全透明，其它的浏览器都能正常显示半透明。图像上颜色较少、并且主要以纯色或者平滑的渐变色填充以及具备较大的亮度差异的图像适合以png8格式存储。svg格式可缩放矢量图形是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式。它由万维网联盟制定，是一个开放标准。SVG格式特点： SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM和 XSL 之类的W3C标准是一个整体SVG跟上面这些图片格式最大的不同，是SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。 bmp格式BMP是一种与硬件设备无关的图像文件格式，使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。这是一种比较老的图片格式。BMP是无损的，但同时这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。虽然同时支持索引色和直接色是一个优点，但是太大的文件格式格式导致它几乎没有用武之地，现在除了在Windows操作系统中还比较常见之外，我们几乎看不到它。WebP格式WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。想象Web上的图片之多，百分之几十的提升，是非常非常大的优化。只可惜，目前只有Chrome浏览器和Opera浏览器支持WebP格式，所以WebP的应用并不广泛。为了使用更先进的技术，比如WebP图片格式，来压缩互联网上传输的数据流量，谷歌甚至提供了Chrome Data Compression Proxy，设置了Chrome Data Compression Proxy作为Web代理之后，你访问的所有网站中的图片，在经过Proxy的时候，都会被转换成WebP格式，以降低图片文件的大小。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。]]></content>
      <categories>
        <category>图像格式</category>
      </categories>
      <tags>
        <tag>图像格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios总结]]></title>
    <url>%2F2019%2F01%2F04%2Faxios%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。在Vue中常用axios来做前后端的交互；上一张git上的star值 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 使用安装：$ npm install axios cdn方式： src=”https://unpkg.com/axios/dist/axios.min.js&quot;基本使用：123Axios.method(&apos;url&apos;,[...data],options).then(function(res)&#123;&#125;).catch(function(err)&#123;&#125;) 合并请求：12345678910111213例如：//定义两个不不同的情请求var q1 =this.axio.get（‘url’)var q2= this.post(&apos;url&apos;,&apos;a=1&apos;)//合并q1,q2请求this.$axios.all([q1,q2]).then(this.$axios.spread((res1,res2)=&gt;&#123; //全成功 this.res1=res1; this.res1=res1;&#125;)).catch(err=&gt;&#123; //只要其中一个失败 console.log(err); &#125;) 配置公共信息： this.$ axios.defaults.baseURL = ‘http://sss/ss/s’ options参数还可以为params查询字符串对象；transformRequest转换请求体数据；headers请求头信息；data请求数据，timeout请求超时场景：所有请求自带的头信息 this.$axios.headers ={};// 覆盖原本默认的头部 this.$ axios.defaults.headers.accept =&apos;abc&apos;//修改个别信息即可 没有使用箭头函数的时候，一定要注意作用域的问题，如上诉代码的that登录的安全机制 xsrfCookieName服务器返回一个xsrf-token令牌，保存起来 xsrfHeaderName 请求自动携带x-xsrf-token=xxx 取消请求 断点续传取消请求 场景：在上传文件的时候，用户发现去、文件错误取消请求123456789101112131415161718const CancelToken = axios.CancelToken;const source = CancelToken.source(); //创建标志请求的源对象axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token // 携带取消的标志 &#125;).catch(function (thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // handle error &#125;&#125;);axios.post(&apos;/user/12345&apos;, &#123; name: &apos;new name&apos;&#125;, &#123; cancelToken: source.token // 携带取消的标志&#125;)source.cancel(&apos;Operation canceled by the user.&apos;); // 取消导致之前的请求 断点续传 场景：文件上传被中断,需要续传 及时获取到已经上传的部分，保存已上传部分： this.loaded = progressEvent.loaded 剪裁文件： this.loaded = progressEvent.loaded // 获取已经上传的部分 var fileData = this.file.slice(this.loaded +1 , this.file,size) //裁剪文件 var fd = new FormData(); fd.append(&apos;file&apos;,fileData); //后续未上传的文件 const CancelToken = axios.CancelToken; const source = CancelToken.source(); this.axios.post(&apos;url&apos;,fd,{ cancelToken: source.token // 携带取消的标志 //处理事件 }) 拦截器 请求拦截器：发起请求之前做的事 响应拦截器：响应回来之后做的事 应用场景1：在请求发起之前，展示一个loading,在响应回来之后，关闭一个loading123456789101112131415161718send:function()&#123;//配置拦截器//use给请求之前做的事可是是多件，可以use很多次this.$ axios.interceptors.request.use(function(config)&#123; console.log(config); return config;&#125;);//响应拦截器this.$ axios.interceptors.reponse.use(function(res)&#123; console.log(res.config); this.isShow = true; //在请求发起之前，展示一个loading return res.config;&#125;);this.$ axios.get(&apos;url&apos;).then(res=&gt;&#123; console.log(&apos;响应回来&apos;,res) this.isShow = false; //在响应回来之后，关闭一个loading&#125; 应用场景2：实现一个类似的cookie机制服务器 —-设置set-cookie:xxx 保存起来在响应中完成在请求之前，本地获取xxx,设置拦截器，请求头 123456789101112131415161718sendAjax:function()&#123; // 请求拦截器 this.$axios.interceptors.request.use((config)=&gt;&#123; var token = localStroage.getItem(&apos;token&apos;); // 设置请求头，类似cookie if（token）&#123; config.headers[&apos;token&apos;] = token ; &#125; this.isShow = true; return res.config; &#125;） // 响应拦截器 this.$axios.interceptors.response.use((res)=&gt;&#123; if（res .headers.token)&#123; //获取服务器的响应头 var token = res.headers.token ; localStroage.setItem(&apos;token&apos;,token) ; &#125; return res.config;&#125;)]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>前后端交互</tag>
        <tag>http请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实现computed原理]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E5%AE%9E%E7%8E%B0computed%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[每当问到VueJS响应式原理，大家可能都会脱口而出“Vue通过Object.defineProperty方法把data对象的全部属性转化成getter/setter，当属性被访问或修改时通知变化”。然而，其内部深层的响应式原理可能很多人都没有完全理解，网络上关于其响应式原理的文章质量也是参差不齐，大多是贴个代码加段注释了事。本文将会从一个非常简单的例子出发，一步一步分析响应式原理的具体实现思路。 一、使数据对象变得“可观测” 首先，我们定义一个数据对象，就以王者荣耀里面的其中一个英雄为例子： const hero = { health: 3000, IQ: 150 } 我们定义了这个英雄的生命值为3000，IQ为150。但是现在还不知道他是谁，不过这不重要，只需要知道这个英雄将会贯穿我们整篇文章，而我们的目的就是通过这个英雄的属性，知道这个英雄是谁。 现在我们可以通过hero.health和hero.IQ直接读写这个英雄对应的属性值。但是，当这个英雄的属性被读取或修改时，我们并不知情。那么应该如何做才能够让英雄主动告诉我们，他的属性被修改了呢？这时候就需要借助Object.defineProperty的力量了。 关于Object.defineProperty的介绍，MDN上是这么说的： Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。在本文中，我们只使用这个方法使对象变得“可观测”，更多关于这个方法的具体内容，请参考https://developer.mozilla.org...，就不再赘述了。 那么如何让这个英雄主动通知我们其属性的读写情况呢？首先改写一下上面的例子： let hero = {} let val = 3000 Object.defineProperty(hero, &apos;health&apos;, { get () { console.log(&apos;我的health属性被读取了！&apos;) return val }, set (newVal) { console.log(&apos;我的health属性被修改了！&apos;) val = newVal } }) 我们通过Object.defineProperty方法，给hero定义了一个health属性，这个属性在被读写的时候都会触发一段console.log。现在来尝试一下： console.log(&apos;我的health属性被读取了！&apos;) // -&gt; 3000 // -&gt; 我的health属性被读取了！ hero.health = 5000 // -&gt; 我的health属性被修改了 可以看到，英雄已经可以主动告诉我们其属性的读写情况了，这也意味着，这个英雄的数据对象已经是“可观测”的了。为了把英雄的所有属性都变得可观测，我们可以想一个办法： /** * 使一个对象转化成可观测对象 * @param { Object } obj 对象 * @param { String } key 对象的key * @param { Any } val 对象的某个key的值 */ function defineReactive (obj, key, val) { Object.defineProperty(obj, key, { get () { // 触发getter console.log(`我的${key}属性被读取了！`) return val }, set (newVal) { // 触发setter console.log(`我的${key}属性被修改了！`) val = newVal } }) } /** * 把一个对象的每一项都转化成可观测对象 * @param { Object } obj 对象 */ function observable (obj) { const keys = Object.keys(obj) keys.forEach((key) =&gt; { defineReactive(obj, key, obj[key]) }) return obj } 现在我们可以把英雄这么定义： const hero = observable({ health: 3000, IQ: 150 }) 读者们可以在控制台自行尝试读写英雄的属性，看看它是不是已经变得可观测的。 二、计算属性 现在，英雄已经变得可观测，任何的读写操作他都会主动告诉我们，但也仅此而已，我们仍然不知道他是谁。如果我们希望在修改英雄的生命值和IQ之后，他能够主动告诉他的其他信息，这应该怎样才能办到呢？假设可以这样： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) 我们定义了一个watcher作为“监听器”，它监听了hero的type属性。这个type属性的值取决于hero.health，换句话来说，当hero.health发生变化时，hero.type也应该发生变化，前者是后者的依赖。我们可以把这个hero.type称为“计算属性”。 那么，我们应该怎样才能正确构造这个监听器呢？可以看到，在设想当中，监听器接收三个参数，分别是被监听的对象、被监听的属性以及回调函数，回调函数返回一个该被监听属性的值。顺着这个思路，我们尝试着编写一段代码： /** * 当计算属性的值被更新时调用 * @param { Any } val 计算属性的值 */ function onComputedUpdate (val) { console.log(`我的类型是：${val}`); } /** * 观测者 * @param { Object } obj 被观测对象 * @param { String } key 被观测对象的key * @param { Function } cb 回调函数，返回“计算属性”的值 */ function watcher (obj, key, cb) { Object.defineProperty(obj, key, { get () { const val = cb() onComputedUpdate(val) return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } 现在我们可以把英雄放在监听器里面，尝试跑一下上面的代码： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) hero.type hero.health = 5000 hero.type // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：脆皮 // -&gt; 我的health属性被修改了！ // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：坦克 现在看起来没毛病，一切都运行良好，是不是就这样结束了呢？别忘了，我们现在是通过手动读取hero.type来获取这个英雄的类型，并不是他主动告诉我们的。如果我们希望让英雄能够在health属性被修改后，第一时间主动发起通知，又该怎么做呢？这就涉及到本文的核心知识点——依赖收集。 三、依赖收集 我们知道，当一个可观测对象的属性被读写时，会触发它的getter/setter方法。换个思路，如果我们可以在可观测对象的getter/setter里面，去执行监听器里面的onComputedUpdate()方法，是不是就能够实现让对象主动发出通知的功能呢？ 由于监听器内的onComputedUpdate()方法需要接收回调函数的值作为参数，而可观测对象内并没有这个回调函数，所以我们需要借助一个第三方来帮助我们把监听器和可观测对象连接起来。 这个第三方就做一件事情——收集监听器内的回调函数的值以及onComputedUpdate()方法。 现在我们把这个第三方命名为“依赖收集器”，一起来看看应该怎么写： const Dep = { target: null } 就是这么简单。依赖收集器的target就是用来存放监听器里面的onComputedUpdate()方法的。 定义完依赖收集器，我们回到监听器里，看看应该在什么地方把onComputedUpdate()方法赋值给Dep.target： function watcher (obj, key, cb) { // 定义一个被动触发函数，当这个“被观测对象”的依赖更新时调用 const onDepUpdated = () =&gt; { const val = cb() onComputedUpdate(val) } Object.defineProperty(obj, key, { get () { Dep.target = onDepUpdated // 执行cb()的过程中会用到Dep.target， // 当cb()执行完了就重置Dep.target为null const val = cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } 我们在监听器内部定义了一个新的onDepUpdated()方法，这个方法很简单，就是把监听器回调函数的值以及onComputedUpdate()给打包到一块，然后赋值给Dep.target。这一步非常关键，通过这样的操作，依赖收集器就获得了监听器的回调值以及onComputedUpdate()方法。作为全局变量，Dep.target理所当然的能够被可观测对象的getter/setter所使用。 重新看一下我们的watcher实例： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) 在它的回调函数中，调用了英雄的health属性，也就是触发了对应的getter函数。理清楚这一点很重要，因为接下来我们需要回到定义可观测对象的defineReactive()方法当中，对它进行改写： function defineReactive (obj, key, val) { const deps = [] Object.defineProperty(obj, key, { get () { if (Dep.target &amp;&amp; deps.indexOf(Dep.target) === -1) { deps.push(Dep.target) } return val }, set (newVal) { val = newVal deps.forEach((dep) =&gt; { dep() }) } }) } 可以看到，在这个方法里面我们定义了一个空数组deps，当getter被触发的时候，就会往里面添加一个Dep.target。回到关键知识点Dep.target等于监听器的onComputedUpdate()方法，这个时候可观测对象已经和监听器捆绑到一块。任何时候当可观测对象的setter被触发时，就会调用数组中所保存的Dep.target方法，也就是自动触发监听器内部的onComputedUpdate()方法。 至于为什么这里的deps是一个数组而不是一个变量，是因为可能同一个属性会被多个计算属性所依赖，也就是存在多个Dep.target。定义deps为数组，若当前属性的setter被触发，就可以批量调用多个计算属性的onComputedUpdate()方法了。 完成了这些步骤，基本上我们整个响应式系统就已经搭建完成，下面贴上完整的代码： /** * 定义一个“依赖收集器” */ const Dep = { target: null } /** * 使一个对象转化成可观测对象 * @param { Object } obj 对象 * @param { String } key 对象的key * @param { Any } val 对象的某个key的值 */ function defineReactive (obj, key, val) { const deps = [] Object.defineProperty(obj, key, { get () { console.log(`我的${key}属性被读取了！`) if (Dep.target &amp;&amp; deps.indexOf(Dep.target) === -1) { deps.push(Dep.target) } return val }, set (newVal) { console.log(`我的${key}属性被修改了！`) val = newVal deps.forEach((dep) =&gt; { dep() }) } }) } /** * 把一个对象的每一项都转化成可观测对象 * @param { Object } obj 对象 */ function observable (obj) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i], obj[keys[i]]) } return obj } /** * 当计算属性的值被更新时调用 * @param { Any } val 计算属性的值 */ function onComputedUpdate (val) { console.log(`我的类型是：${val}`) } /** * 观测者 * @param { Object } obj 被观测对象 * @param { String } key 被观测对象的key * @param { Function } cb 回调函数，返回“计算属性”的值 */ function watcher (obj, key, cb) { // 定义一个被动触发函数，当这个“被观测对象”的依赖更新时调用 const onDepUpdated = () =&gt; { const val = cb() onComputedUpdate(val) } Object.defineProperty(obj, key, { get () { Dep.target = onDepUpdated // 执行cb()的过程中会用到Dep.target， // 当cb()执行完了就重置Dep.target为null const val = cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } const hero = observable({ health: 3000, IQ: 150 }) watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) console.log(`英雄初始类型：${hero.type}`) hero.health = 5000 // -&gt; 我的health属性被读取了！ // -&gt; 英雄初始类型：脆皮 // -&gt; 我的health属性被修改了！ // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：坦克 上述代码可以直接在code pen点击预览或者浏览器控制台上执行。 四、代码优化在上面的例子中，依赖收集器只是一个简单的对象，其实在defineReactive()内部的deps数组等和依赖收集有关的功能，都应该集成在Dep实例当中，所以我们可以把依赖收集器改写一下： class Dep { constructor () { this.deps = [] } depend () { if (Dep.target &amp;&amp; this.deps.indexOf(Dep.target) === -1) { this.deps.push(Dep.target) } } notify () { this.deps.forEach((dep) =&gt; { dep() }) } } Dep.target = null 同样的道理，我们对observable和watcher都进行一定的封装与优化，使这个响应式系统变得模块化： class Observable { constructor (obj) { return this.walk(obj) } walk (obj) { const keys = Object.keys(obj) keys.forEach((key) =&gt; { this.defineReactive(obj, key, obj[key]) }) return obj } defineReactive (obj, key, val) { const dep = new Dep() Object.defineProperty(obj, key, { get () { dep.depend() return val }, set (newVal) { val = newVal dep.notify() } }) } } class Watcher { constructor (obj, key, cb, onComputedUpdate) { this.obj = obj this.key = key this.cb = cb this.onComputedUpdate = onComputedUpdate return this.defineComputed() } defineComputed () { const self = this const onDepUpdated = () =&gt; { const val = self.cb() this.onComputedUpdate(val) } Object.defineProperty(self.obj, self.key, { get () { Dep.target = onDepUpdated const val = self.cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } } 然后我们来跑一下： const hero = new Observable({ health: 3000, IQ: 150 }) new Watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }, (val) =&gt; { console.log(`我的类型是：${val}`) }) console.log(`英雄初始类型：${hero.type}`) hero.health = 5000 // -&gt; 英雄初始类型：脆皮 // -&gt; 我的类型是：坦克]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>computed</tag>
        <tag>响应式</tag>
        <tag>数据绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Vue Router是Vue.js的官方路由器。它与Vue.js核心深度集成，使用Vue.js构建单页应用程序变得轻而易举。 使用步骤 引入vue-router对象 安装插件：Vue.use(VueRouter) 创建一个路由对象 var router = new VueRouter（{routes：[]}） 配置路由对象 :routes:[{path:’/login/:name’,component:xx} ] 将配置好的路由对象关联到事列中:router:router 指定路由改变局部的位置:router-link ：to=‘’ 查询字符串 配置：to =“{name:’detail’,query:{id:hero.id} }” 规则：{name：‘detail’,path:’/detail’,component:Detail} 获取：this.$route.query.id 生成： path方式 配置：to =“{name:’detail’,params:{id:hero.id} }” 规则：{name：‘detail’,path:’/detail’/ :id} 获取：this.$route.params.id 生成：path方式需要在路由规则中声明位置 vue-router中的对象 $route路由信息对象，只读对象 $router路由操作对象，只写对象 嵌套路由单页面应用开发多页面的路由。多个组件按不同的锚点值填入不同的位置使用规则： router-view中包含router-view 路由规则中存在子路由 辅助知识点 路由meta元数据—-meta对于路由规则是否需要验证权限的配置,路由对象中和name属性同级 {meta：{isChecked：true}} 路由钩子—权限控制的函数执行时期 每次路由匹配后，渲染组件到router-view之前 router.beforeEach(function(to,from,next){ }):next()直接放行，next(){}跳转到相应的路由]]></content>
      <categories>
        <category>Vue知识点总结</category>
      </categories>
      <tags>
        <tag>路由，vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础知识点]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[基础知识点框架与库的区别jquery库+DOM操作+http请求 = 全家桶 如何起步 引包Vue.js 通过Vue对象，new Vue（options） 配置options对象 el:发生动作的目的地 template:模板（必须为一个根节点） data函数，返回的是一个对象 components:key是组件名，value是组件对象 methods：配合事件 props：子组件接受的参数设置 插值表达式：对象、字符串、判断后的布尔值、三元表达式#### 常用指令 - v-text:元素的innerText属性 - v-html：元素的innerHTML属性 - v-if:判断是否插入，v-else-if，v-else和v-if必须是相邻的元素 - v-show:隐藏元素，给元素加上display：none - v-bind:绑定属性，单向数据流,v-bind:属性=‘变量’ 简写：属性名=‘xxx’ - v-model：双向数据绑定，v-on:事件名=‘函数’ 简写： @事件名 - v-on:绑定事件，处理自定义原生事件，v-on:事件名=“表达式 ||函数名 ” - v-for:循环 用法：v-for=“item in stus” 如果stus为数组，（item，index） in stus 如果stus为obj，（value,key,index） in stus#### 全局组件场景：公共性功能组件，减少冗余代码全局API：Vue.component(‘组件名’，组件对象)#### 过滤器给数据的显示进行操作，如反转，改变属性等filter：全局过滤器，Vue.filter(‘过滤器名’，过滤方式fun)filters：组件内的过滤器，Vue.filters(‘过滤器名’，过滤方式fun)，使用:内容 | 过滤器名#### watch监视单个属性改变，无法监视复杂类型，因为监视的是对象地址，地址没有改变，改变的只是属性#### computed监视多个：object | array computed：{ 监视的业务名:function(){}} 使用： slotvue内置的组件，父组件向子组件传DOM结构，而props是动态的数据，如果有选择性传递，就具名插槽，以name来选择，使用的对应的slot=name值即可 组件生命周期所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 beforeCreate：组件创建之前，拿不到数据 created:可以操作数据，并且可以实现vue-&gt;页面的额影响，用于发起http请求 beforeMount：vue起作用，装载数据到DOM之前，应用：vue启动前的DOM mounted：vue起作用，装载数据到DOM之前，应用：vue启动后的DOM，仅执行一次 beforeUpdate:基于数据的改变才会触发，数据改变之前，应用：获取原DOM updated：基于数据的改变才会触发，数据改变之后,应用：获取新DOM beforeDestroy：销毁前，做一些功能的释放，如本地保存 destroyed：销毁后 activated：激活 deactivated：停用 小结：频繁的销毁和创建组件？不合理，使用keep_alive内置组件包裹起来，对应的是actived和deactived声明周期；created和actived：都是子组件状态，created没有被keep-alive内置组件包括，actived被包裹； 获取DOM元素在组件的DOM部分任意标签写上ref=”xxx”,通过组件对象，this.$refs.xxx获取到元素]]></content>
      <categories>
        <category>Vue知识点总结</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>指令</tag>
        <tag>生命周期 ，组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2018]]></title>
    <url>%2F2018%2F12%2F30%2F%E6%88%91%E7%9A%842018%2F</url>
    <content type="text"><![CDATA[前言感觉今年过的很快，其实回头看看经历了很多很多。在2018的尾巴上，回顾这一年的经历，只为明年做的更好。 回首过去关于学习这一年，教研室从一楼搬到了五楼，搬砖的工作量也相应的随楼层的增加而增加。前前后后忙了两个项目，主要的技术栈是bootstrap、Vue、elementUI、webpack等开发工具，那段时间很忙，很头疼，因为没有前辈指导，所有踩的坑都得一个一个一遍又一遍的踩，却感觉很充实，那段时间是自己知识积累最快的一个阶段了吧。后面的一段时间自学了小程序，自己也开发了一个小程序、因审核内容受限、所以没上线。方向是好的，自己可以拿来练练手。12月，联系了一个前辈、打算慢慢参与开源，虽然目前来说是一些维护的事，但也好在为来年的计划做点铺垫。其他方面，学会了烘培、拉花、做咖啡，学会了游泳，也尝试了未曾尝试过的菜肴。 关于秋招秋招算是自己沉淀知识的阶段，年初买的红皮书、权威指南等前端方面的书籍也在秋招的时候看了个遍。过程总的来说很幸运也很遗憾，幸运的是在6月就拿了一个研究所的offer，心里也不是特别的慌；遗憾的是因错过阿里三面的电话而失之交臂，投提前批，找内推就如同石沉大海，没有回应。后面去上海参加上汽举行的“摩尔100计划”，也算散心了，运气也好了起来，最后拿到的offer中，有高薪资的、有发展好的，没有选择最高薪资的、也没有选择发展最好的，而是选择了自己觉得最适合的公司吧。对于秋招的总结，大概就是以下几点： 基础知识要扎实，特别是css，js方面。 在js方面，不仅要有基础，更要有深度。 框架方面，不能只会用，更要了解原理，深入源码 工程方面，要考虑到网络通信、上线bug、维护的问题。 知识的广度，不能局限在前端，后台、安全也很重要。 要有大前端的思想，不能局限在一个模子里面。 关于毕设作为一个前端开发，毕设做人脸识别也算是一种挑战，当找完工作回归教研室看我的开题报告的时候，我第一反应这谁的毕设？谁写的开题报告？我为啥做这个？典型的灵魂三问，然而我不知道系列。疯狂的看英文文献，找创新点，标数据集，训练模型，路途还很遥远，壮士还需努力啊。 关于健身2018年参加了人生第一场正式的马拉松、没有想象中那么难、只是需要坚持下去就好了，路途中有很多让我很感动的风景：单腿带着拐杖走的人，年过七旬的人，坐在轮椅里的人，带着小孩坚持走的人；你会发现，比你优秀的、没你生来完善的人都在努力坚持着自己的生活、你还有什么理由不努力呢？2018年坚持健身的又一年，很庆幸自己没有理由的坚持了下来并养成了习惯，因为是阳光的、美好的，所以更想去坚持吧。 关于旅行18年去的地方不多也不少，时常怀念自己大学毕业义工旅行的日子，真正做到随遇而安的小安，开了属于自己的民宿的露露，她们都走上了自己喜欢的那条路。对于旅行，我一直是坚持的，在路上的。这一年徒步了白雪皑皑的四人同、带老妈小弟逛了成都、打卡了上海、自驾了川西大环线，又一次去了色达，遇见了稻城，更遇见了自己。 展望未来保持对生活的热情，保持内心的孩子气，做自己想做的事情，无论生活变成什么样子，可以受苦，可以跌倒，可以失落，但是不能当废柴。努力做好下面的： 因上努力，果上随缘 好好学习，顺利毕业 多多读书，坚持阅读 努力工作，尽早适应 参与开源，多看源码 做好总结，及时更博 坚持锻炼，坚持健身 做好理财，出去旅行 自爱沉稳，而后爱人 都说2019年属猪的一年，肯定不缺肉吃。我想我的2019年，少点焦虑，多点自律。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阮一峰ES6之Promise对象的理解]]></title>
    <url>%2F2018%2F12%2F30%2F%E9%98%AE%E4%B8%80%E5%B3%B0ES6%E4%B9%8BPromise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、Promise的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象的特点（1）对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来“承若”；（2）一旦状态改变就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。二、用法创建一个实例： const promise = new Promise(function(resolve,reject){ //some code if(//异步操作成功){ resolve(value); }else{ reject(error); } });Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。Promise 新建后就会立即执行。 let promise = new Promise(function(resolve, reject) { console.log(‘Promise’); resolve(); }); promise.then(function() { console.log(‘resolved.’); }); console.log(‘Hi!’); 执行结果：上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 // Promise // Hi! // resolved下面是一个用Promise对象实现的 Ajax 操作的例子。 const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(“GET”, url); client.onreadystatechange = handler; client.responseType = “json”; client.setRequestHeader(“Accept”, “application/json”); client.send(); }); return promise; }; getJSON(“/posts.json”).then(function(json) { console.log(‘Contents: ‘ + json); }, function(error) { console.error(‘出错了’, error); });上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。如果调用resolve函数和reject函数时带有参数，那么他们的参数会被传递给回调函数，reject函数的参数通常是Error对象的实例，表示抛出的错误，resolve函数的参数除了正常的值以外，还可以是另一个promise实例； var p1 = new Promise(function (resolve, reject) { // … }); var p2 = new Promise(function (resolve, reject) { // … resolve(p1); }) p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。三、Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(“/posts.json”).then(function(json) { return json.post; }).then(function(post) { // … });上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。四、Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 getJSON(‘/posts.json’).then(function(posts) { // … }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(‘发生错误！’, error); });上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。五、Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]);上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。下面是一个具体的例子。 // 生成一个Promise对象的数组 const promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(‘/post/‘ + id + “.json”); }); Promise.all(promises).then(function (posts) { // … }).catch(function(reason){ // … });上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。下面是另一个例子。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result) .catch(e =&gt; e); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result) .catch(e =&gt; e); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // [“hello”, Error: 报错了]上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // Error: 报错了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流与去抖]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E6%8A%96%2F</url>
    <content type="text"><![CDATA[####使用场景以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。 window对象的resize、scroll事件 拖拽时的mousemove事件 射击游戏中的mousedown、keydown事件 文字输入、自动完成的keyup事件 实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的0执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。 ####debounce抖动：如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。接口定义： /** * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行 * @param idle {number} 空闲时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ debounce(idle,action) 简单实现1：利用定时器，让函数执行延迟500毫秒，在500毫秒内如果有函数又被调用则删除上一次调用，这次调用500毫秒后执行，如此往复 window.onscroll = function(){//lazyload(); debounce(lazyload,window); }; function debounce(method,context){ clearTimeout(method.timeout); method.timeout = setTimeout(function(){ method.call(context); },500); } function lazyload(){ console.log(&quot;scroll执行了&quot;+scrollnum); } 简单实现2： 还有一种节流方式，是通过返回闭包的形式，可以设置延迟时间，两者运行的结果是一样，但是我在实际操作的时候设置延迟500时，滚动过了一会才执行了,设置为delay为100的时候在视觉上就没有感觉延迟。而且函数也只滚动了一次。 function debounce1(method,delay){ var timer = null; return function(){ var context = this,args = arguments; clearTimeout(timer); timer = setTimeout(function(){ method.apply(context,args); },delay); } } ####throttle当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了(对于实现keyup事件的提示也没有意义了)，所以可以为函数添加一个参数作为到固定间隔必须执行，到了这个时间间隔就必须执行，这个时候就引入了节流： 节流：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期接口定义： /** * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay * @param delay {number} 延迟时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ throttle(delay,action) 简单实现： var throttle = function(delay, action){ var last = 0; return function(){ var curr = +new Date(); if (curr - last &gt; delay){ action.apply(this, arguments); last = curr ; } } } 简单实现2： function throttle2(method, delay, time) { var timeout,startTime = new Date(); return function() { var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout);// 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) { method.apply(context, args); startTime = curTime;//没达到触发间隔，重新设定定时器 } else { timeout = setTimeout(method, delay); } };]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之this的指向理解]]></title>
    <url>%2F2018%2F12%2F29%2FJS%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.this是什么？ this是对象自动生成的一个内部对象，是在运行时基于函数的执行环境绑定的，因为函数的调用场合不同，this的值也有变化。this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时 。这句话目前也只能说在ES5中才是正确的，而在ES6的箭头函数中，this的指向就是在定义的时候就确定的。 2. this的绑定规则this的绑定总共差不多有下面五种： 默认绑定 隐式绑定 显示绑定 new绑定 ES6箭头函数中的this2.1.默认绑定12345function foo()&#123; console.log(this.a); // 10&#125;var a = 10;foo(); 作为独立函数的调用，this指向的是全局对象window，而在严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。 2.2.隐式绑定123456789function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;foo(); //undefinedobj.foo(); // 2 foo() 这个就是默认绑定,等价于打印 window.a ,故输出 undefined ；obj.foo()，函数有上下文对象，即obj，这种情况下， 函数里的this默认绑定为上下文对象 ，等价于打印 obj.a ,故输出2 。如果是链性的关系，比如 xx.yy.obj.foo(); , 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。再看下一个情况：12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数别名var a =,10; // a是全局对象的属性bar(); // 10 虽然bar为obj.foo的引用，但实际上引用的是foo函数本身，此时this指向为默认绑定，指向的window，所以输出10 2.3.显示绑定 显示绑定就是call apply bind，call和apply它们的作用都是改变函数的this指向 ， 第一个参数都是 设置this对象 。两个函数的区别：call从第二个参数开始所有的参数都是 原函数的参数。apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。1234567function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 调用foo时强制把foo的this绑定到obj上 bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回。123456function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 10 &#125;;foo = foo.bind(obj);foo(); // 10 2.4.new绑定js中的只要用new修饰的 函数就是’构造函数’，准确来说是 函数的 构造调用 ，因为在js中并不存在所谓的’构造函数’。那么用new 做到函数的 构造调用 后，js帮我们做了什么工作呢: 1234567function createNew() let obj = new Object() // 创建一个空的对象 let Con = [].shift.call(arguments) // 获得构造函数 obj.__proto__ = Con.prototype // 链接到原型 let result = Con.apply(obj, arguments) // 绑定 this，执行构造函数 return typeof result === &apos;object&apos; ? result : obj // 确保 new 出来的是个对象&#125; 1、创建（或者说构造）一个新对象。2、这个新对象会被执行[[Prototype]]连接。3、这个新对象会绑定到函数调用的this。4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 12345678function foo()&#123; this.a = 10; console.log(this);&#125;foo(); // window对象console.log(window.a); // 10 默认绑定var obj = new foo(); //// 等价于 foo &#123; a : 10 &#125;; var obj = foo; console.log(obj.a); // 10 new绑定 特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例: function foo(){ this.a = 10; return new String(&quot;啊哈哈&quot;); } var obj = new foo(); console.log(obj.a); // undefined console.log(obj); // &quot;啊哈哈&quot; 2.5 ES6箭头函数中的thisfoo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。12345678910111213function foo() &#123; return (a) =&gt; &#123; //返回一个箭头函数 console.log( this.a ); // this继承自foo() &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;var bar = foo.call( obj1 );bar.call( obj2 ); // 2，不是3！ 3. 优先级new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 4. 总结1.如果函数是在某个 上下文对象 下被调用：this绑定的是那个上下文对象，例 : var obj = { foo : foo }; obj.foo(); foo 中的 this 就是 obj2.如果函数是使用 call,apply,bind 来调用的：this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj3.如果函数被 new 修饰：this绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar4.如果都不是，则是默认绑定 5.常见题目分析var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); // 20 //隐式绑定,this指向上下文obj var foo = function(){ console.log(this.x); } foo(); //10 默认绑定 指向的是window对象 } }; obj.f(); 12345678function foo(arg)&#123; this.a = arg; return this&#125;;var a = foo(1);var b = foo(10);console.log(a.a); // ?undefinedconsole.log(b.a); // ?10 分析：foo(1)执行，应该不难看出是默认绑定吧 , this指向了window，函数里等价于 window . a = 1,return window;var a = foo(1) 等价于 window . a = window , 很多人都忽略了 var a 就是window.a ，将刚刚赋值的 1 替换掉了。所以这里的 a 的值是 window , a . a 也是window ， 即window . a = window ; window . a . a = window;foo(10) 和第一次一样，都是默认绑定，这个时候， 将window.a 赋值成 10 ，注意这里是关键，原来window.a = window ,现在被赋值成了10，变成了值类型，所以现在 a.a = undefined。(验证这一点只需要将var b = foo(10);删掉，这里的 a.a 还是window)var b = foo(10); 等价于 window.b = window;本题中所有变量的值，a = window.a = 10 , a.a = undefined , b = window , b.a = window.a = 10; 1234567891011121314151617181920var num = 1;var myObject = &#123; num: 2, add: function() &#123; this.num = 3; (function() &#123; console.log(this.num); //默认绑定 指向的window 输出1 this.num = 4; &#125;)(); console.log(this.num); &#125;, sub: function() &#123; console.log(this.num) &#125;&#125;myObject.add(); console.log(myObject.num); console.log(num);var sub = myObject.sub;sub(); 依次输出 1 3 3 4 4]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈我对vuex的理解]]></title>
    <url>%2F2018%2F12%2F29%2F%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Vuex%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在近期做得项目中，用到Vue框架，必不可少的也用到vuex状态管理，再加上面试中也被问到了，索性把这一块拿出来抽时间整理一下： 核心概念Vuex 是适用于 Vue.js 应用的状态管理库，为应用中的所有组件提供集中式的状态存储与操作，保证了所有状态以可预测的方式进行修改。官网的一张图： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，重新渲染Vue Components，界面随之更新 完整流程 单向数据流规定所有的数据操作必须通过 action – mutation – state change 的流程来进行，再结合Vue的数据视图双向绑定特性来实现页面的展示更新 state单一状态树那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： // 创建一个 Counter 组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return store.state.count } } } 然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： const app = new Vue({ el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; ` }) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from &apos;vuex&apos; export default { computed: mapState({ count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：而且Mutation必须为同步函数当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：store.commit(‘increment’) const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) ActionAction 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(&apos;increment&apos;) } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 分发 ActionAction 通过 store.dispatch 方法触发：store.dispatch(‘increment’)在组件中分发 Action:在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： import { mapActions } from &apos;vuex&apos; export default { methods: { ...mapActions([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` // `mapActions` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` ]), ...mapActions({ add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` }) }}]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
</search>
