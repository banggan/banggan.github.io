<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阮一峰ES6之Promise对象的理解]]></title>
    <url>%2F2018%2F12%2F30%2F%E9%98%AE%E4%B8%80%E5%B3%B0ES6%E4%B9%8BPromise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、Promise的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象的特点（1）对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来“承若”；（2）一旦状态改变就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。二、用法创建一个实例： const promise = new Promise(function(resolve,reject){ //some code if(//异步操作成功){ resolve(value); }else{ reject(error); } });Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。Promise 新建后就会立即执行。 let promise = new Promise(function(resolve, reject) { console.log(‘Promise’); resolve(); }); promise.then(function() { console.log(‘resolved.’); }); console.log(‘Hi!’); 执行结果：上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 // Promise // Hi! // resolved下面是一个用Promise对象实现的 Ajax 操作的例子。 const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(“GET”, url); client.onreadystatechange = handler; client.responseType = “json”; client.setRequestHeader(“Accept”, “application/json”); client.send(); }); return promise; }; getJSON(“/posts.json”).then(function(json) { console.log(‘Contents: ‘ + json); }, function(error) { console.error(‘出错了’, error); });上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。如果调用resolve函数和reject函数时带有参数，那么他们的参数会被传递给回调函数，reject函数的参数通常是Error对象的实例，表示抛出的错误，resolve函数的参数除了正常的值以外，还可以是另一个promise实例； var p1 = new Promise(function (resolve, reject) { // … }); var p2 = new Promise(function (resolve, reject) { // … resolve(p1); }) p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。三、Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(“/posts.json”).then(function(json) { return json.post; }).then(function(post) { // … });上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。四、Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 getJSON(‘/posts.json’).then(function(posts) { // … }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(‘发生错误！’, error); });上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。五、Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]);上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。下面是一个具体的例子。 // 生成一个Promise对象的数组 const promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(‘/post/‘ + id + “.json”); }); Promise.all(promises).then(function (posts) { // … }).catch(function(reason){ // … });上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。下面是另一个例子。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result) .catch(e =&gt; e); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result) .catch(e =&gt; e); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // [“hello”, Error: 报错了]上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // Error: 报错了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数节流与去抖]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E6%8A%96%2F</url>
    <content type="text"><![CDATA[####使用场景以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。 window对象的resize、scroll事件 拖拽时的mousemove事件 射击游戏中的mousedown、keydown事件 文字输入、自动完成的keyup事件 实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的0执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。 ####debounce抖动：如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。接口定义： /** * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行 * @param idle {number} 空闲时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ debounce(idle,action) 简单实现1：利用定时器，让函数执行延迟500毫秒，在500毫秒内如果有函数又被调用则删除上一次调用，这次调用500毫秒后执行，如此往复 window.onscroll = function(){//lazyload(); debounce(lazyload,window); }; function debounce(method,context){ clearTimeout(method.timeout); method.timeout = setTimeout(function(){ method.call(context); },500); } function lazyload(){ console.log(&quot;scroll执行了&quot;+scrollnum); } 简单实现2： 还有一种节流方式，是通过返回闭包的形式，可以设置延迟时间，两者运行的结果是一样，但是我在实际操作的时候设置延迟500时，滚动过了一会才执行了,设置为delay为100的时候在视觉上就没有感觉延迟。而且函数也只滚动了一次。 function debounce1(method,delay){ var timer = null; return function(){ var context = this,args = arguments; clearTimeout(timer); timer = setTimeout(function(){ method.apply(context,args); },delay); } } ####throttle当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了(对于实现keyup事件的提示也没有意义了)，所以可以为函数添加一个参数作为到固定间隔必须执行，到了这个时间间隔就必须执行，这个时候就引入了节流： 节流：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期接口定义： /** * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay * @param delay {number} 延迟时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ throttle(delay,action) 简单实现： var throttle = function(delay, action){ var last = 0; return function(){ var curr = +new Date(); if (curr - last &gt; delay){ action.apply(this, arguments); last = curr ; } } } 简单实现2： function throttle2(method, delay, time) { var timeout,startTime = new Date(); return function() { var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout);// 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) { method.apply(context, args); startTime = curTime;//没达到触发间隔，重新设定定时器 } else { timeout = setTimeout(method, delay); } };]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS之this的指向理解]]></title>
    <url>%2F2018%2F12%2F29%2FJS%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.this是什么？ this是对象自动生成的一个内部对象，是在运行时基于函数的执行环境绑定的，因为函数的调用场合不同，this的值也有变化。this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时 。这句话目前也只能说在ES5中才是正确的，而在ES6的箭头函数中，this的指向就是在定义的时候就确定的。 2. this的绑定规则this的绑定总共差不多有下面五种： 默认绑定 隐式绑定 显示绑定 new绑定 ES6箭头函数中的this2.1.默认绑定12345function foo()&#123; console.log(this.a); // 10&#125;var a = 10;foo(); 作为独立函数的调用，this指向的是全局对象window，而在严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。 2.2.隐式绑定123456789function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;foo(); //undefinedobj.foo(); // 2 foo() 这个就是默认绑定,等价于打印 window.a ,故输出 undefined ；obj.foo()，函数有上下文对象，即obj，这种情况下， 函数里的this默认绑定为上下文对象 ，等价于打印 obj.a ,故输出2 。如果是链性的关系，比如 xx.yy.obj.foo(); , 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。再看下一个情况：12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数别名var a =,10; // a是全局对象的属性bar(); // 10 虽然bar为obj.foo的引用，但实际上引用的是foo函数本身，此时this指向为默认绑定，指向的window，所以输出10 2.3.显示绑定 显示绑定就是call apply bind，call和apply它们的作用都是改变函数的this指向 ， 第一个参数都是 设置this对象 。两个函数的区别：call从第二个参数开始所有的参数都是 原函数的参数。apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。1234567function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 调用foo时强制把foo的this绑定到obj上 bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回。123456function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 10 &#125;;foo = foo.bind(obj);foo(); // 10 2.4.new绑定js中的只要用new修饰的 函数就是’构造函数’，准确来说是 函数的 构造调用 ，因为在js中并不存在所谓的’构造函数’。那么用new 做到函数的 构造调用 后，js帮我们做了什么工作呢: 1234567function createNew() let obj = new Object() // 创建一个空的对象 let Con = [].shift.call(arguments) // 获得构造函数 obj.__proto__ = Con.prototype // 链接到原型 let result = Con.apply(obj, arguments) // 绑定 this，执行构造函数 return typeof result === &apos;object&apos; ? result : obj // 确保 new 出来的是个对象&#125; 1、创建（或者说构造）一个新对象。2、这个新对象会被执行[[Prototype]]连接。3、这个新对象会绑定到函数调用的this。4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 12345678function foo()&#123; this.a = 10; console.log(this);&#125;foo(); // window对象console.log(window.a); // 10 默认绑定var obj = new foo(); //// 等价于 foo &#123; a : 10 &#125;; var obj = foo; console.log(obj.a); // 10 new绑定 特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例: function foo(){ this.a = 10; return new String(&quot;啊哈哈&quot;); } var obj = new foo(); console.log(obj.a); // undefined console.log(obj); // &quot;啊哈哈&quot; 2.5 ES6箭头函数中的thisfoo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。12345678910111213function foo() &#123; return (a) =&gt; &#123; //返回一个箭头函数 console.log( this.a ); // this继承自foo() &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;var bar = foo.call( obj1 );bar.call( obj2 ); // 2，不是3！ 3. 优先级new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 4. 总结1.如果函数是在某个 上下文对象 下被调用：this绑定的是那个上下文对象，例 : var obj = { foo : foo }; obj.foo(); foo 中的 this 就是 obj2.如果函数是使用 call,apply,bind 来调用的：this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj3.如果函数被 new 修饰：this绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar4.如果都不是，则是默认绑定 5.常见题目分析var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); // 20 //隐式绑定,this指向上下文obj var foo = function(){ console.log(this.x); } foo(); //10 默认绑定 指向的是window对象 } }; obj.f(); 12345678function foo(arg)&#123; this.a = arg; return this&#125;;var a = foo(1);var b = foo(10);console.log(a.a); // ?undefinedconsole.log(b.a); // ?10 分析：foo(1)执行，应该不难看出是默认绑定吧 , this指向了window，函数里等价于 window . a = 1,return window;var a = foo(1) 等价于 window . a = window , 很多人都忽略了 var a 就是window.a ，将刚刚赋值的 1 替换掉了。所以这里的 a 的值是 window , a . a 也是window ， 即window . a = window ; window . a . a = window;foo(10) 和第一次一样，都是默认绑定，这个时候， 将window.a 赋值成 10 ，注意这里是关键，原来window.a = window ,现在被赋值成了10，变成了值类型，所以现在 a.a = undefined。(验证这一点只需要将var b = foo(10);删掉，这里的 a.a 还是window)var b = foo(10); 等价于 window.b = window;本题中所有变量的值，a = window.a = 10 , a.a = undefined , b = window , b.a = window.a = 10; 1234567891011121314151617181920var num = 1;var myObject = &#123; num: 2, add: function() &#123; this.num = 3; (function() &#123; console.log(this.num); //默认绑定 指向的window 输出1 this.num = 4; &#125;)(); console.log(this.num); &#125;, sub: function() &#123; console.log(this.num) &#125;&#125;myObject.add(); console.log(myObject.num); console.log(num);var sub = myObject.sub;sub(); 依次输出 1 3 3 4 4]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[谈谈我对vuex的理解]]></title>
    <url>%2F2018%2F12%2F29%2F%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Vuex%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在近期做得项目中，用到Vue框架，必不可少的也用到vuex状态管理，再加上面试中也被问到了，索性把这一块拿出来抽时间整理一下： 核心概念Vuex 是适用于 Vue.js 应用的状态管理库，为应用中的所有组件提供集中式的状态存储与操作，保证了所有状态以可预测的方式进行修改。官网的一张图： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，重新渲染Vue Components，界面随之更新 完整流程 单向数据流规定所有的数据操作必须通过 action – mutation – state change 的流程来进行，再结合Vue的数据视图双向绑定特性来实现页面的展示更新 state单一状态树那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： // 创建一个 Counter 组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return store.state.count } } } 然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： const app = new Vue({ el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; ` }) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return this.$store.state.count } } } mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from &apos;vuex&apos; export default { computed: mapState({ count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：而且Mutation必须为同步函数当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：store.commit(‘increment’) const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) ActionAction 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(&apos;increment&apos;) } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 分发 ActionAction 通过 store.dispatch 方法触发：store.dispatch(‘increment’)在组件中分发 Action:在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： import { mapActions } from &apos;vuex&apos; export default { methods: { ...mapActions([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` // `mapActions` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` ]), ...mapActions({ add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` }) }}]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
</search>
