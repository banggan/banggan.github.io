<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS异步处理的进化史]]></title>
    <url>%2F2019%2F08%2F26%2FJS%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%9A%84%E8%BF%9B%E5%8C%96%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[前言javascript是一门单线程的语言，也就是说一次只能完成一件任务，如果有多个任务，就需要排队进行处理。如果一个任务耗时很长，后面的任务也必须排队等待，这样大大的影响了整个程序的执行。为了解决这个问题，javascript语言将任务分为两种模式： 同步：当我们打开网站，网页的页面骨架渲染和页面元素渲染，就是一大推同步任务。 异步：我们在浏览新闻时，加载图片或音乐之类占用资源大且耗时久的任务就是异步任务。 本文主要针对近两年javascript的发展，主要介绍异步处理的进化史。目前，在javascript异步处理中，有以下几种方式： callback 回调函数是最早解决异步编程的方法。无论是常见的setTimeout还是ajax请求，都是采用回调的形式把事情在某一固定的时刻进行执行。 12345678 //常见的：setTimeout setTimeout(function callback()&#123; console.log('aa');&#125;, 1000);//ajax请求ajax(url,function callback()&#123; console.log("ajax success",res);&#125;) 回调函数的处理一般将函数callback作为参数传进函数，在合适的时候被调用执行。回调函数的优点就是简单、容易理解和实现，但有个致命的缺点，容易出现回调地狱（Callback hell）,即多个回调函数嵌套使用。造成代码可读性差、可维护性差且只能在回调中处理异常。 123456789ajax(url, () =&gt; &#123; //todo ajax(url1, () =&gt; &#123; //todo ajax(url2, () =&gt; &#123; //todo &#125;) &#125;)&#125;) 事件监听 事件监听采用的是事件驱动的模式。事件的执行不取决于代码的顺序，而是某个事件的发生。 假设有两个函数，为f1绑定一个事件(jQuery的写法),当f1函数发生success事件时，执行函数f2: 1f1.on('success',f2); 对f1进行改写： 123456function f1()&#123; ajax(url,() =&gt; &#123; //todo f1.trigger('success');//触发success事件，从而执行f2函数 &#125;)&#125; 事件监听的方式较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。 发布订阅 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做 发布/订阅模式（publish-subscribe pattern），又称观察者模式”（observer pattern） 。 123456789101112//利用jquery的插件实现//首先，f2向消息中心订阅success事件jQuery.subscribe('success',f2);//对f1进行改写：function f1()&#123; ajax(url,() =&gt; &#123; //todo jQuery.publish('success');//当f1执行完毕后，向消息中心jQuery发布success事件，从而执行f2函数 &#125;)&#125;//f2执行完毕后，可以取消订阅jQuery.unsubscribe('success',f2) 该方法和事件监听的性质类似，但我们可以通过消息中心来查阅一共有多少个信号，每个信号有多少个订阅者。 Promise Promise是CommonJS工作组提出的一种规范,可以获取异步操作的消息，也是异步处理中常用的一种解决方案。Promise的出现主要是用来解决回调地狱、支持多个并发的请求，获取并发请求的数据并且解决异步的问题。 12345678910111213141516let p = new Promise((resolve, reject) =&gt; &#123; //做一些异步操作 setTimeout(()=&gt;&#123; let num = parseInt(Math.random()*100); if(num &gt; 50)&#123; resolve("num &gt; 50"); // 如果数字大于50就调用成功的函数，并且将状态变成Resolved &#125;else&#123; reject("num &lt;50");// 否则就调用失败的函数，将状态变成Rejected &#125; &#125;,10000)&#125;);p.then((res) =&gt; &#123; console.log(res);&#125;).catch((err) =&gt;&#123; console.log(err);&#125;) Promise有三种状态：等待pending、成功fulfied、失败rejected；状态一旦改变，就不会再变化，在Promise对象创建后，会马上执行。等待状态可以变为fulfied状态并传递一个值给相应的状态处理方法，也可能变为失败状态rejected并传递失败信息。任一一种情况出现时，Promise对象的 then 方法就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，均为 Function。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法）。 需要注意的是： Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以可以被链式调用，如下图： Promise的方法： Promise.all(iterable)：谁执行得慢，以谁为准执行回调。返回一个promise对象，只有当iterable里面的所有promise对象成功后才会执行。一旦iterable里面有promise对象执行失败就触发该对象的失败。对象在触发成功后，会把一个包iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。 Promise.race(iterable): 谁执行得快，以谁为准执行回调。iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.reject(err)与Promise.resolve(res) Generators/yield Generators是ES6提供的异步解决方案，其最大的特点就是可以控制函数的执行。可以理解成一个内部封装了很多状态的状态机，也是一个遍历器对象生成函数。Generator 函数的特征： function关键字与函数名之间有一个星号； 函数体内部使用yield表达式，定义不同的内部状态； 通过yield暂停函数，next启动函数，每次返回的是yield表达式结果。next可以接受参数，从而实现在函数运行的不同阶段，可以从外部向内部注入不同的值。next返回一个包含value和done的对象，其中value表示迭代的值，后者表示迭代是否完成。 举个例子： 123456789101112131415function* createIterator(x) &#123; let y = yield (x+1) let z = 2*(yield(y/3)) return (x+y+z)&#125;// generators可以像正常函数一样被调用，不同的是会返回一个 iteratorlet iterator = createIterator(4);console.log(iterator.next()); // &#123;value:5,done:false&#125;console.log(iterator.next()); // &#123;value:NaN,done:false&#125;console.log(iterator.next()); // &#123;value:NaN,done:true&#125;let iterator1 = createIterator(4);//返回一个iterator//next传参数console.log(iterator1.next()); // &#123;value:5,done:false&#125;console.log(iterator1.next(12)); // &#123;value:4,done:false&#125;console.log(iterator1.next(15)); // &#123;value:46,done:true&#125; 代码分析： 当不参数时，next的value返回NaN； 当传参数时，作为上一个yeild的值，在第一次使用next时，传参数无效，只有第二次开始，才有效。 第一次执行next时，函数会被暂停在yeild(x+1),所以返回的是4+1=5； 第二次执行next时，传入的12为上一次yeild表达式的值，所以y=12,返回的是12/3=4； 第三次执行next时，传入的15为上一次yeild表达式的值，所以z=30,y=12;x=4,返回30+12+4=46 async/await初入async/await async/await在ES7提出，是目前在javascript异步处理的终极解决方案。 async 其本质是 Generator 函数的语法糖。相较于Generator放入改进如下： 内置执行器：Generator 函数的执行必须靠执行器，而async函数自带执行器。其调用方式与普通函数一模一样，不需要调next方法; 更好的语义：async表示定义异步函数，而await表示后面的表达式需要等待，相较于*和yeild更语义化； 更广的适用性：co模块约定，yield命令后面只能是Thunk函数或 Promise对象。而 async 函数的await命令后面则可以是Promise 或者 原始类型的值; 返回Promise:async 函数返回值是Promise对象，比 Generator函数返回的 Iterator对象方便，可以直接使用 then() 方法进行链式调用； 语法分析 async语法 用来定义异步函数，自动将函数转换为promise对象,可以使用then来添加回调，其内部return的值作为then回调的参数。 123456async function f()&#123; return "hello async";&#125;f().then((res) =&gt; &#123; //通过then来添加回调且内部返回的res作为回调的参数 console.log(res); // hello async&#125;) 在异步函数的内部可以使用await，其返回的promise对象必须等到内部所以await命令后的promise对象执行完，才会发生状态变化即执行then回调。 1234567891011const delay = function(timeout)&#123; return new Promise(function(resolve)&#123; return setTimeout(resolve, timeout); &#125;);&#125;async function f()&#123; await delay(1000); await delay(2000); return '完成';&#125;f().then(res =&gt; console.log(res));//需要等待3秒之后才会打印：完成 await即表示异步等待，用来暂停异步函数的执行，只能在异步函数和promise使用，且当使用在promise前面，表示等待promise完成并返回结果。 12345async function f() &#123; return await 1 //await后面不是Promise的话，也会被转换为一个立即为resolve的promise&#125;;f().then( res =&gt; console.log("处理成功",res))//打印出：处理成功 1 .catch(err =&gt; console.log("处理是被",err))////打印出：Promise&#123;&lt;resolved&gt;:undefined&#125; 错误处理 如果await后面的异步出现错误，等同于async返回的promise对象为reject,其错误会被catch的回调函数接收到。需要注意的是，当 async 函数中只要一个 await 出现 reject 状态，则后面的 await 都不会被执行。 123456let a;async function f()&#123; await Promise.reject("error") a = await 1 //该await并没有执行 &#125;err().then(res =&gt; console.log(a)) 怎么处理呢，可以把第一个await放在try/catch，遇到函数的时候，可以将错误抛出并往下执行。 123456789async function f() &#123; try&#123; await Promise.reject('error'); &#125;catch(error)&#123; console.log(error); &#125; return await 1&#125;f().then(res =&gt; console.log('成功', res))//成功打印出1 如果有多个await处理，可以统一放在try/catch模块中,而且async可以使得try/catch同时处理同步和异步错误。 总结 通过以上六种javascript异步处理的常用方法，可以看出async/await可以说是异步终极解决方案了,最后看一下async/await用得最多的场景： 如果一个业务需要很多个异步操作组成，并且每个步骤都依赖于上一步的执行结果，这里采用不同的延时来体现： 12345678910111213141516171819202122232425262728//首先定义一个延时函数function delay(time) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(time), time); &#125;);&#125;//采用promise链式调用实现delay(500).then(result =&gt; &#123; return delay(result + 1000)&#125;).then(result =&gt; &#123; return delay(result + 2000)&#125;).then(result =&gt; &#123; console.log(result) //3500ms后打印出3500&#125;).catch(error =&gt; &#123; console.log(error)&#125;) //采用async实现async function f()&#123; const r1 = await delay(500) const r2 = await delay(r1+1000) const r3 = await delay(r2+2000) return r3&#125;f().then(res =&gt;&#123; console.log(res)&#125;).catch(err=&gt;&#123; console.log(err)&#125;) 可以看出，采用promise实现采用了很多then进行不停的链式调用，使得代码变得冗长和复杂且没有语义化。而 async/await首先使用同步的方法来写异步，代码非常清晰直观，而且使代码语义化，一眼就能看出代码执行的顺序，最后 async 函数自带执行器，执行的时候无需手动加载。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>异步，promise，await，Generators</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之对象类型]]></title>
    <url>%2F2019%2F01%2F21%2FTypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在TypeScript中，利用接口(Interfaces)来定义对象的类型。 在面向对象语言中，接口（Interfaces）、它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。在TypeScript中没有接口的概念，在编译成JavaScript的时候，所有的接口会被擦出掉，而TypeScript的核心之一就是类型检查。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约并让代码看起来更好理解。 TypeScript中的接口可用于对对象的形状进行描述，也可用于对类的一部分进行抽象，如：12345678910111213interface Person &#123; name:string; age：number;&#125;function put(person:Person)&#123; console.log(&quot;hello&quot; + person.name+&quot;I&apos;m&quot;+ person.age);&#125;let Tom: Person = &#123; //这里的对象只要包含必要的属性且值类型正确就可以 name: &apos;Tom&apos;, age: 25&#125;; 如果不给传进去的对象指定是接口类型的数据，那么传入的对象参数可以包含其他属性，编译器会检查必要的属性是否存在且判断类型是否正确。如果是是指定了接口类型的数据，多属性和少属性均会出错123456789let Tom: Person = &#123;//两种情况均不允许 name: &apos;Tom&apos;&#125;;let Tom: Person = &#123; name: &apos;Tom&apos;, age: 25, gender: &apos;male&apos;&#125;; 可选属性在实际的开发中，接口里的属性不全是需要的，就可以使用可选属性： 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。 12345678910111213//这里name和age均是可选属性，在传对象的时候name和age可有可无interface Person &#123; name?: string; age?: number;&#125;function getInfo(p:person)&#123; console.log(p.name); console.log(p.age);&#125;let Tom =&#123;name:&apos;tom&apos;&#125;let Tom =&#123;age:20&#125;getInfo(Tom); 任意属性如果我们希望一个借口有任意的属性，可使用 [propName: string]: any来实现：12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let Tom: Person = &#123; name: &apos;Tom&apos;, gender: &apos;male&apos;&#125;; 一旦定义了任意属性，则确定和可选属性必须是他的子属性。123456let tom: Person = &#123; name: &apos;Tom&apos;, age: 25, gender: &apos;male&apos;&#125;;//error TS2411: Property &apos;age&apos; of type &apos;number&apos; is not assignable to string index type &apos;string&apos;. 这里的任意属性是string，而age是number，number不是string的子属性，所以报错 只读属性如果我们希望对象的属性只能在对象创建时候修改其值，在属性名的前面用readonly来指定只读属性：123456789101112131415interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: &apos;Tom&apos;, gender: &apos;male&apos;&#125;;tom.id = 9527;//error TS2540: Cannot assign to &apos;id&apos; because it is a constant or a read-only property. 定义只读数组TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：123let a: ReadonlyArray&lt;number&gt; =[1,2,3,4];a[0] =2;//errora.length = 9;//error 函数类型为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。123456789interface getStr&#123;/* 函数传入两个number类型的参数，返回一个string*/ (x:number,y:number):string;&#125;let myStr: getStr;myStr = function(grade:number,class:nember)&#123; return `$&#123;grade&#125;年级$&#123;class&#125;班`;&#125;console.log(myStr(2,3)); //2年级3班 可索引类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = [&quot;Bob&quot;, &quot;Fred&quot;];let myStr: string = myArray[0];//打印Bob 定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值 TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。 类类型一个类去实现接口，而不是直接把接口拿来用12345678910111213interface Clock&#123;//定义一个由属性和方法的接口 currentTime:Date; setTime(d:Date);&#125;//Time类实现了Clock接口class Time implements Clock&#123; currentTime:Date; setTime(d:Date)&#123; this.currentTime = d &#125; constructor(h: number, m: number) &#123; &#125;//类的静态部分，不会检查&#125; 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。123456789//接口可以继承接口 并且可以多继承interface shape&#123; color:string;&#125;interface pen extends shape&#123; width:number;&#125;//创建一个对象并指定泛型circle.color=&quot;red&quot;;//这里可以获取color属性circle.width=2;//有width属性 一个接口继承多个接口，创建多个接口的合成接口123456789101112131415interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface pen extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;pen&gt;&#123;&#125;; //创建一个对象并指定泛型square.color = &quot;blue&quot;;square.sideLength = 10; 混合类型所谓的混合类型就是在一个接口中定义多种类型，比如属性，函数，数组等： interface Counter { (start: number): string; interval: number; reset(): void; //没有返回值的函数 } function getCounter(): Counter { let counter = &lt;Counter&gt;function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0;]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>Interfaces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之变量声明]]></title>
    <url>%2F2019%2F01%2F18%2FTypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%8B%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[变量声明因为TypeScript是JavaScript的超集，所以它本身就支持let和const。const是对let的一个增强，它能阻止对一个变量再次赋值，在TS中，主要就是var let const,就简单说一下用法吧： var声明12345678910111213141516171819202122var a =10; //定义变量function f() &#123; //函数内部定义变量 var message = &quot;Hello, world!&quot;; return message;&#125;//函数嵌套调用function f() &#123; var a = 1; a = 2; var b = g(); a = 3; return b; function g() &#123; //g可以获取到f函数定义的a return a; &#125;&#125;f(); // returns 2 let声明let的声明与var一样，重要的是，let和var的区别是实现块级作用域，而且不存在变量提升，且不能重复赋值。 这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里12345678910111213141516//内部能访问到b,但是外部就不能访问； function f(input: boolean) &#123; let a = 100; if (input) &#123; // Still okay to reference &apos;a&apos; let b = a + 1; return b; &#125; // Error: &apos;b&apos; doesn&apos;t exist here return b;&#125;//暂时性死区的例子a++; // illegal to use &apos;a&apos; before it&apos;s declared;let a; 重复定义12let x = 10;let x = 20; // 错误，不能在1个作用域里多次声明`x` 并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。同样会发生错误12345678function f(x) &#123; let x = 100; // error: interferes with parameter declaration&#125;function g() &#123; let x = 100; var x = 100; // error: can&apos;t have both declarations of &apos;x&apos;&#125; 并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。1234567891011function f(condition, x) &#123; if (condition) &#123; let x = 100; return x; &#125; return x;&#125;f(false, 0); // returns 0f(true, 0); // returns 100 当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事。123for (let i = 0; i &lt; 10 ; i++) &#123; setTimeout(function() &#123;console.log(i); &#125;, 100 * i);&#125; //输出0-9 const声明const和let基本一致，只是const声明的变量被赋值后不能再改变（所以对于const来说，只声明不赋值，就会报错），作用域同let1234567891011121314151617const numLivesForCat = 9;const kitty = &#123; name: &quot;Aurora&quot;, numLives: numLivesForCat,&#125;// Errorkitty = &#123; name: &quot;Danielle&quot;, numLives: numLivesForCat&#125;;// all &quot;okay&quot;kitty.name = &quot;Rory&quot;;kitty.name = &quot;Kitty&quot;;kitty.name = &quot;Cat&quot;;kitty.numLives--; let vs. const使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。 解构解构(destructuring assignment)是一种表达式，将数组或者对象中的数据赋给另一变量。 数组解构1234let input = [1, 2,3];let [f, s] = input;console.log(f); // outputs 1console.log(s); // outputs 2 交换变量值123[f,s] = [s,f];console.log(f)； // outputs 2console.log(s); // outputs 1 使用…创建剩余变量1234let nums= [1,2,3,4]let [f, ...rest] = nums;console.log(f); // 输出： 1console.log(rest);// 输出： [2,3,4] 忽略数组中某些元素123let [first] = [1, 2, 3, 4];console.log(first); // 输出： 1let [, second, , fourth] = [1, 2, 3, 4]; 对象解构12345678let o = &#123; a: &quot;foo&quot;, b: 12, c: &quot;bar&quot;&#125;let &#123; a, b &#125; = o;console.log(a); // 输出： fooconsole.log(b);// 输出： 12 将对象o.a赋值给a,0.b赋值给b，这里的a,b都是对象属性名且必须一致，而属性c则会忽略 上述例子中声明的变量a和b必须和对象中属性一致，如果想换一个名字，写法如下：1234567891011let &#123; a: aa, b: bb &#125; = o;默认值let o = &#123; a: &quot;foo&quot;, b: undefined, c: &quot;bar&quot;&#125;let &#123;a, b=1&#125;= o;console.log(a); // 输出： fooconsole.log(b);// 输出： 1 当属性b的值为undefined时，解构表达式会使用默认值 展开展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 数组展开1234let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5];console.log(bpthPlus)；输出 [0,1,2,3,4,5] 对象展开1234let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123; ...defaults, food: &quot;rich&quot; &#125;;console.log(search); //输出：&#123;food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot;&#125; 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：123let defaults = &#123; food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;;let search = &#123;food: &quot;rich&quot;, ...defaults &#125;;console.log(search); //输出：&#123;food: &quot;spicy&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot;&#125; 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：12345678910class C &#123; p = 12; m() &#123; &#125;&#125;let c = new C();let clone = &#123; ...c &#125;;clone.p; // okclone.m(); // error!]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>var</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>解构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之基本类型]]></title>
    <url>%2F2019%2F01%2F16%2FTypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript的类型分为原始数据类型和对象类型，原始数据类型主要包括：布尔值、数值、字符串、null、undefined 布尔值在TypeScript中，使用boolean定义布尔值类型1let do: boolean = true 使用构造函数Boolean创造的对象并不是布尔值12let createdByNewBoolean: boolean = new Boolean(1);// index.ts(1,5): error TS2322: Type &apos;Boolean&apos; is not assignable to type &apos;boolean&apos;. 因为 new Boolean()返回的是一个Boolean对象：1let createdByNewBoolean: boolean = new Boolean(1); 直接调用Boolean也可以返回一个boolean类型：1let createByBoolean:boolean = Boolean(1); 在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。 数值使用number定义的数值类型： 12345678let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity; 编译结果： 12345678var decLiteral = 6;var hexLiteral = 0xf00d;// ES6 中的二进制表示法var binaryLiteral = 10;// ES6 中的八进制表示法var octalLiteral = 484;var notANumber = NaN;var infinityNumber = Infinity; 字符串使用 string 定义字符串类型： 123456let myName: string = 'Tom';let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is $&#123;myName&#125;.I'll be $&#123;myAge + 1&#125; years old next month.`; 编译结果： 1234var myName = 'Tom';var myAge = 25;// 模板字符串var sentence = "Hello, my name is " + myName + ".\nI'll be " + (myAge + 1) + " years old next month."; 排列TypeScript与JavaScript一样，允许使用值数组。数组类型可以用两种方式之一编写。在第一个中，使用后跟[]元素的类型来表示该元素类型的数组：1let list: number[] = [1, 2, 3]; 另一种方式：使用通用数组类型Array1let list: Array&lt;number&gt; = [1, 2, 3]; 元组元组类型表示一个数组，其中已知固定数量的元素的类型，但不必相同。例如，您可能希望将值表示为a string和a 的对number：123456// Declare a tuple typelet x: [string, number];// Initialize itx = [&quot;hello&quot;, 10]; // OK// Initialize it incorrectlyx = [10, &quot;hello&quot;]; // Error 访问具有已知索引的元素时，将检索正确的类型：12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, &apos;number&apos; does not have &apos;substr&apos; 枚举默认情况下，枚举从开始编号开始编号0，可以手动设置其中一个成员的值来更改：12enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green; 枚举的一个便利功能是,可以从数值转到枚举中该值的名称。例如，如果我们有值，2但不确定在Color上面的枚举中映射到了什么，我们可以查找相应的名称：1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // Displays &apos;Green&apos; as its value is 2 abov 空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 123function warnUser(): void &#123; console.log("This is my warning message");&#125; 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; Null 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： 12let u: undefined = undefined;let n: null = null; undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12// 这样不会报错let num: number = undefined; 123// 这样也不会报错let u: undefined;let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量： 1234let u: void;let num: number = u;// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'. 任意值我们可能需要描述在编写应用程序时我们不知道的变量类型。这些值可能来自动态内容，例如来自用户或第三方库。在这些情况下，我们希望选择退出类型检查，并让值通过编译时检查。为此，我们使用以下any类型标记这些123let notSure: any = 4;notSure = "maybe a string instead";notSure = false; // okay, definitely a boolean 如果是一个普通类型，在赋值过程中改变类型是不被允许的： 1234let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 但如果是 any 类型，则允许被赋值为任意类型。 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 在任意值上访问任何属性都是允许的： 123let anyThing: any = 'hello';console.log(anyThing.myName);console.log(anyThing.myName.firstName); 也允许调用任何方法： 1234let anyThing: any = 'Tom';anyThing.setName('Jerry');anyThing.setName('Jerry').sayHello();anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： 12345let something;something = 'seven';something = 7;something.setName('Tom'); 等价于 12345let something: any;something = 'seven';something = 7;something.setName('Tom');]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript学习笔记之初入TypeScript]]></title>
    <url>%2F2019%2F01%2F16%2FTypeScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%9D%E5%85%A5TypeScript%2F</url>
    <content type="text"><![CDATA[what?TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript；主要提供类型系统和对ES6的支持；免费开源。 官网：http://www.typescriptlang.org/ why？优势 增加代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了；可以在编译阶段就发现大部分错误，这总比在运行时候出错好；增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。 非常包容 TypeScript 是JavaScript的超集，.js文件可以直接重命名为 .ts 即可；即使不显式的定义类型，也能够自动做出类型推论；可以定义从简单到复杂的几乎一切类型；即使TypeScript 编译报错，也可以生成 JavaScript 文件；兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 拥有活跃的社区 优势 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量安装TypeScript 的命令行工具安装方法如下： 1npm install -g typescript 以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。 编译一个 TypeScript 文件很简单： 1tsc hello.ts 我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。 编辑器TypeScript 最大的优势便是增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。 主流的编辑器都支持 TypeScript，这里我推荐使用Sublime Text 其他编辑器或 IDE 对 TypeScript 的支持： Visual Studio Code Atom WebStorm Vim Emacs Eclipse Visual Studio 2015 Visual Studio 2013 Hello TypeScript我们从一个简单的例子开始。 将以下代码复制到 hello.ts 中： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = 'Tom';console.log(sayHello(user)); 然后执行 1tsc hello.ts 这时候会生成一个编译好的文件 hello.js： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = 'Tom';console.log(sayHello(user)); TypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以。 上述例子中，我们用 : 指定 person 参数类型为 string。但是编译为 js 之后，并没有什么检查的代码被插入进来。 TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。 let 是 ES6 中的关键字，和 var 类似，用于定义一个局部变量，可以参阅 let 和 const 命令。 下面尝试把这段代码编译一下： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = [0, 1, 2];console.log(sayHello(user)); 编辑器中会提示错误，编译的时候也会出错： 1index.ts(6,22): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'. 但是还是生成了 js 文件： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = [0, 1, 2];console.log(sayHello(user)); TypeScript 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件。 如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json，请参阅官方手册（中文版）。]]></content>
      <categories>
        <category>TypeScript学习笔记</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码解读之基础前言]]></title>
    <url>%2F2019%2F01%2F05%2FVue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言从开始学习Vue到现在也有1年半了吧，以后的工作也是大部分的Vue相关，为了打好基础，方便迎接年后Vue3.0，给自己定了一个计划-有针对性的读源码并做一个系列的总结。 Flow静态检测Vue.js 的源码利用了 Flow 做了静态类型检查，所以要对flow有一定的了解诶啊在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下： flow ├── compiler.js # 编译相关 ├── component.js # 组件数据结构 ├── global-api.js # Global API 结构 ├── modules.js # 第三方库定义 ├── options.js # 选项相关 ├── ssr.js # 服务端渲染相关 ├── vnode.js # 虚拟 node 相关 Vue源码目录在git上下载Vue的源码，可以看到src的子目录如下： src ├── compiler # 编译相关 ├── core # 核心代码 ├── platforms # 不同平台的支持，有web+weex ├── server # 服务端渲染 ├── sfc # .vue 文件解析 ├── shared # 共享代码 Vue源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件，它的内容实际上是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下： { &quot;script&quot;: { &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;build:ssr&quot;: &quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;, &quot;build:weex&quot;: &quot;npm run build --weex&quot; } } 先打开构建的入口 JS 文件，在 scripts/build.js 中：这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。1234567891011121314let builds = require(&apos;./config&apos;).getAllBuilds()// filter builds via command line argif (process.argv[2]) &#123; const filters = process.argv[2].split(&apos;,&apos;) builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf(&apos;weex&apos;) === -1 &#125;)&#125;build(builds) Vue入口import Vue from ‘./runtime/index’ 定义Vue的入口，那Vue是如何被定义的呢？123import Vue from &apos;core/index&apos; //重点！重点引入代码.........export default Vue 在core中的index代码如下：123456789import Vue from &apos;./instance/index&apos; //重点 引入Vue定义代码import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;initGlobalAPI(Vue) // 重点！！1！初始化全局的APIObject.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123; get: isServerRendering&#125;)........export default Vue Vue 的真实定义：终于看到了 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。 import { initMixin } from &apos;./init&apos; import { stateMixin } from &apos;./state&apos; import { renderMixin } from &apos;./render&apos; import { eventsMixin } from &apos;./events&apos; import { lifecycleMixin } from &apos;./lifecycle&apos; import { warn } from &apos;../util/index&apos; function Vue (options) { if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue) ) { warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) } this._init(options) } initMixin(Vue) stateMixin(Vue) eventsMixin(Vue) lifecycleMixin(Vue) renderMixin(Vue) export default Vue initGlobalAPI：Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中： 123456789101112131415161718192021222324252627282930313233export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== &apos;production&apos;) &#123; configDef.set = () =&gt; &#123; warn( &apos;Do not replace the Vue.config object, set individual fields instead.&apos; ) &#125; &#125; Object.defineProperty(Vue, &apos;config&apos;, configDef) Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &apos;s&apos;] = Object.create(null) &#125;) Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue)&#125;]]></content>
      <categories>
        <category>Vue源码解读</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码，Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像格式的区别以及应用场景]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[在实际的开发中，遇到了这个问题，有点理不清，特来整理一次： jpg格式全名应该是JPEG。JPEG 图片以 24 位颜色存储单个光栅图像。JPEG 是与平台无关的格式，支持最高级别的压缩，不过，这种压缩是有损耗的。渐近式JPEG文件支持交错。可以提高或降低 JPEG文件压缩的级别。但是，文件大小是以图像质量为代价的。压缩比率可以高达 100:1。（JPEG 格式可在 10:1 到 20:1 的比率下轻松地压缩文件，而图片质量不会下降。）JPEG压缩可以很好地处理写实摄影作品。但是，对于颜色较少、对比级别强烈、实心边框或纯色区域大的较简单的作品，JPEG 压缩无法提供理想的结果。有时，压缩比率会低到5:1，严重损失了图片完整性。这一损失产生的原因是，JPEG 压缩方案可以很好地压缩类似的色调，但是 JPEG 压缩方案不能很好地处理亮度的强烈差异或处理纯色区域。Jpeg格式特点： 透明性：它不支持透明性 动画：它不支持动画 损耗性：除了一些比如说（仅仅是90、180、270度旋转），裁切，从标准类型到先进类型，编辑图片的原数据之外，所有其它操作对jpeg图像的处理都会使得它的质量损失，所以我们在编辑过程一般用png作为过渡格式。 隔行渐进显示，它支持隔行渐进显示（但是ie浏览器并不支持这个属性，但是ie会在整个图像信息完全达到的时候显示）。由上可以看出Jpeg是最适web上面的摄影图片和数字照相机中。根据惊叹我们在页面中使用的商品图片、采用人像或者好、实物素材制作的广告更适合采用JPG格式保存。gif格式GIF(GraphicsInterchange Format)的原义是“图像互换格式”，是CompuServe公司在 1987年开发的图像文件格式。GIF文件的数据，是一种基于LZW算法的连续色调的无损压缩格式。其压缩率一般在50％左右，它不属于任何应用程序。目前几乎所有相关软件都支持它，公共领域有大量的软件在使用GIF图像文件。GIF图像文件的数据是经过压缩的，而且是采用了可变长度等压缩算法。所以GIF的图像深度从lbit到8bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。gif 格式特点： 透明性：gif是一种布尔透明类型，即它可以使全透明，也可是全不透明，但是它并没有半透明的（alpha透明）。 动画：gif格式支持动画。 无损耗性：gif是一种无损耗的图像格式，这也意味着你可以对gif图片做任何操作也不会使得图像质量产生损耗。 水平扫描：gif是使用一种叫做LZW的算法进行压缩的，当压缩gif的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的gif图片比竖向的gif更加小。例如50010的图片比10500的图片更加小。 间隔渐进显示：gif支持可选择性的间隔渐进显示。由以上特点看出只有256种颜色的gif图片不适合照片，但它适合对颜色要求不高的图形（比如说图标、图表等）。png格式PNG是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。流式网络图形格式(Portable Network Graphic Format，PNG)名称来源于非官方的“PNG’s NotGIF”，是一种位图文件(bitmapfile)存储格式，读成“ping”。PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据。PNG使用从LZ77派生的无损数据压缩算法Png格式特点： 类型：Png这种图片格式包括了许多类，但是在实践的大致中可以分为256色的png和全色的png，你完全可以用256色的png代替gif，用全色的png代替jpeg。 透明性：png是完全支持alpha透明的（透明、半透明、不透明），尽管有两个怪异的现象在ie6（下面详细讨论） 动画：它不支持动画Png8的在ie中的怪异表现：半透明的png8在ie6以下的浏览器显示为全透明。alpha透明的全色PNG（png32）在ie6中会出现背景颜色（通常是灰色）上面可以总结：全透明的png8可以在任一浏览器正常显示（就像gif一样）。半透明的png8在除了ie6及其一下的浏览器下错误的显示成全透明，其它的浏览器都能正常显示半透明。图像上颜色较少、并且主要以纯色或者平滑的渐变色填充以及具备较大的亮度差异的图像适合以png8格式存储。svg格式可缩放矢量图形是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式。它由万维网联盟制定，是一个开放标准。SVG格式特点： SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM和 XSL 之类的W3C标准是一个整体SVG跟上面这些图片格式最大的不同，是SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。 bmp格式BMP是一种与硬件设备无关的图像文件格式，使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。这是一种比较老的图片格式。BMP是无损的，但同时这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。虽然同时支持索引色和直接色是一个优点，但是太大的文件格式格式导致它几乎没有用武之地，现在除了在Windows操作系统中还比较常见之外，我们几乎看不到它。WebP格式WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。想象Web上的图片之多，百分之几十的提升，是非常非常大的优化。只可惜，目前只有Chrome浏览器和Opera浏览器支持WebP格式，所以WebP的应用并不广泛。为了使用更先进的技术，比如WebP图片格式，来压缩互联网上传输的数据流量，谷歌甚至提供了Chrome Data Compression Proxy，设置了Chrome Data Compression Proxy作为Web代理之后，你访问的所有网站中的图片，在经过Proxy的时候，都会被转换成WebP格式，以降低图片文件的大小。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。]]></content>
      <categories>
        <category>图像格式</category>
      </categories>
      <tags>
        <tag>图像格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios总结]]></title>
    <url>%2F2019%2F01%2F04%2Faxios%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。在Vue中常用axios来做前后端的交互；上一张git上的star值 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 使用安装：$ npm install axios cdn方式： src=”https://unpkg.com/axios/dist/axios.min.js&quot;基本使用：123Axios.method(&apos;url&apos;,[...data],options).then(function(res)&#123;&#125;).catch(function(err)&#123;&#125;) 合并请求：12345678910111213例如：//定义两个不不同的情请求var q1 =this.axio.get（‘url’)var q2= this.post(&apos;url&apos;,&apos;a=1&apos;)//合并q1,q2请求this.$axios.all([q1,q2]).then(this.$axios.spread((res1,res2)=&gt;&#123; //全成功 this.res1=res1; this.res1=res1;&#125;)).catch(err=&gt;&#123; //只要其中一个失败 console.log(err); &#125;) 配置公共信息： this.$ axios.defaults.baseURL = ‘http://sss/ss/s’ options参数还可以为params查询字符串对象；transformRequest转换请求体数据；headers请求头信息；data请求数据，timeout请求超时场景：所有请求自带的头信息 this.$axios.headers ={};// 覆盖原本默认的头部 this.$ axios.defaults.headers.accept =&apos;abc&apos;//修改个别信息即可 没有使用箭头函数的时候，一定要注意作用域的问题，如上诉代码的that登录的安全机制 xsrfCookieName服务器返回一个xsrf-token令牌，保存起来 xsrfHeaderName 请求自动携带x-xsrf-token=xxx 取消请求 断点续传取消请求 场景：在上传文件的时候，用户发现去、文件错误取消请求123456789101112131415161718const CancelToken = axios.CancelToken;const source = CancelToken.source(); //创建标志请求的源对象axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token // 携带取消的标志 &#125;).catch(function (thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // handle error &#125;&#125;);axios.post(&apos;/user/12345&apos;, &#123; name: &apos;new name&apos;&#125;, &#123; cancelToken: source.token // 携带取消的标志&#125;)source.cancel(&apos;Operation canceled by the user.&apos;); // 取消导致之前的请求 断点续传 场景：文件上传被中断,需要续传 及时获取到已经上传的部分，保存已上传部分： this.loaded = progressEvent.loaded 剪裁文件： this.loaded = progressEvent.loaded // 获取已经上传的部分 var fileData = this.file.slice(this.loaded +1 , this.file,size) //裁剪文件 var fd = new FormData(); fd.append(&apos;file&apos;,fileData); //后续未上传的文件 const CancelToken = axios.CancelToken; const source = CancelToken.source(); this.axios.post(&apos;url&apos;,fd,{ cancelToken: source.token // 携带取消的标志 //处理事件 }) 拦截器 请求拦截器：发起请求之前做的事 响应拦截器：响应回来之后做的事 应用场景1：在请求发起之前，展示一个loading,在响应回来之后，关闭一个loading123456789101112131415161718send:function()&#123;//配置拦截器//use给请求之前做的事可是是多件，可以use很多次this.$ axios.interceptors.request.use(function(config)&#123; console.log(config); return config;&#125;);//响应拦截器this.$ axios.interceptors.reponse.use(function(res)&#123; console.log(res.config); this.isShow = true; //在请求发起之前，展示一个loading return res.config;&#125;);this.$ axios.get(&apos;url&apos;).then(res=&gt;&#123; console.log(&apos;响应回来&apos;,res) this.isShow = false; //在响应回来之后，关闭一个loading&#125; 应用场景2：实现一个类似的cookie机制服务器 —-设置set-cookie:xxx 保存起来在响应中完成在请求之前，本地获取xxx,设置拦截器，请求头 123456789101112131415161718sendAjax:function()&#123; // 请求拦截器 this.$axios.interceptors.request.use((config)=&gt;&#123; var token = localStroage.getItem(&apos;token&apos;); // 设置请求头，类似cookie if（token）&#123; config.headers[&apos;token&apos;] = token ; &#125; this.isShow = true; return res.config; &#125;） // 响应拦截器 this.$axios.interceptors.response.use((res)=&gt;&#123; if（res .headers.token)&#123; //获取服务器的响应头 var token = res.headers.token ; localStroage.setItem(&apos;token&apos;,token) ; &#125; return res.config;&#125;)]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>前后端交互</tag>
        <tag>http请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实现computed原理]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E5%AE%9E%E7%8E%B0computed%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[每当问到VueJS响应式原理，大家可能都会脱口而出“Vue通过Object.defineProperty方法把data对象的全部属性转化成getter/setter，当属性被访问或修改时通知变化”。然而，其内部深层的响应式原理可能很多人都没有完全理解，网络上关于其响应式原理的文章质量也是参差不齐，大多是贴个代码加段注释了事。本文将会从一个非常简单的例子出发，一步一步分析响应式原理的具体实现思路。 一、使数据对象变得“可观测” 首先，我们定义一个数据对象，就以王者荣耀里面的其中一个英雄为例子： const hero = { health: 3000, IQ: 150 } 我们定义了这个英雄的生命值为3000，IQ为150。但是现在还不知道他是谁，不过这不重要，只需要知道这个英雄将会贯穿我们整篇文章，而我们的目的就是通过这个英雄的属性，知道这个英雄是谁。 现在我们可以通过hero.health和hero.IQ直接读写这个英雄对应的属性值。但是，当这个英雄的属性被读取或修改时，我们并不知情。那么应该如何做才能够让英雄主动告诉我们，他的属性被修改了呢？这时候就需要借助Object.defineProperty的力量了。 关于Object.defineProperty的介绍，MDN上是这么说的： Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。在本文中，我们只使用这个方法使对象变得“可观测”，更多关于这个方法的具体内容，请参考https://developer.mozilla.org...，就不再赘述了。 那么如何让这个英雄主动通知我们其属性的读写情况呢？首先改写一下上面的例子： let hero = {} let val = 3000 Object.defineProperty(hero, &apos;health&apos;, { get () { console.log(&apos;我的health属性被读取了！&apos;) return val }, set (newVal) { console.log(&apos;我的health属性被修改了！&apos;) val = newVal } }) 我们通过Object.defineProperty方法，给hero定义了一个health属性，这个属性在被读写的时候都会触发一段console.log。现在来尝试一下： console.log(&apos;我的health属性被读取了！&apos;) // -&gt; 3000 // -&gt; 我的health属性被读取了！ hero.health = 5000 // -&gt; 我的health属性被修改了 可以看到，英雄已经可以主动告诉我们其属性的读写情况了，这也意味着，这个英雄的数据对象已经是“可观测”的了。为了把英雄的所有属性都变得可观测，我们可以想一个办法： /** * 使一个对象转化成可观测对象 * @param { Object } obj 对象 * @param { String } key 对象的key * @param { Any } val 对象的某个key的值 */ function defineReactive (obj, key, val) { Object.defineProperty(obj, key, { get () { // 触发getter console.log(`我的${key}属性被读取了！`) return val }, set (newVal) { // 触发setter console.log(`我的${key}属性被修改了！`) val = newVal } }) } /** * 把一个对象的每一项都转化成可观测对象 * @param { Object } obj 对象 */ function observable (obj) { const keys = Object.keys(obj) keys.forEach((key) =&gt; { defineReactive(obj, key, obj[key]) }) return obj } 现在我们可以把英雄这么定义： const hero = observable({ health: 3000, IQ: 150 }) 读者们可以在控制台自行尝试读写英雄的属性，看看它是不是已经变得可观测的。 二、计算属性 现在，英雄已经变得可观测，任何的读写操作他都会主动告诉我们，但也仅此而已，我们仍然不知道他是谁。如果我们希望在修改英雄的生命值和IQ之后，他能够主动告诉他的其他信息，这应该怎样才能办到呢？假设可以这样： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) 我们定义了一个watcher作为“监听器”，它监听了hero的type属性。这个type属性的值取决于hero.health，换句话来说，当hero.health发生变化时，hero.type也应该发生变化，前者是后者的依赖。我们可以把这个hero.type称为“计算属性”。 那么，我们应该怎样才能正确构造这个监听器呢？可以看到，在设想当中，监听器接收三个参数，分别是被监听的对象、被监听的属性以及回调函数，回调函数返回一个该被监听属性的值。顺着这个思路，我们尝试着编写一段代码： /** * 当计算属性的值被更新时调用 * @param { Any } val 计算属性的值 */ function onComputedUpdate (val) { console.log(`我的类型是：${val}`); } /** * 观测者 * @param { Object } obj 被观测对象 * @param { String } key 被观测对象的key * @param { Function } cb 回调函数，返回“计算属性”的值 */ function watcher (obj, key, cb) { Object.defineProperty(obj, key, { get () { const val = cb() onComputedUpdate(val) return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } 现在我们可以把英雄放在监听器里面，尝试跑一下上面的代码： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) hero.type hero.health = 5000 hero.type // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：脆皮 // -&gt; 我的health属性被修改了！ // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：坦克 现在看起来没毛病，一切都运行良好，是不是就这样结束了呢？别忘了，我们现在是通过手动读取hero.type来获取这个英雄的类型，并不是他主动告诉我们的。如果我们希望让英雄能够在health属性被修改后，第一时间主动发起通知，又该怎么做呢？这就涉及到本文的核心知识点——依赖收集。 三、依赖收集 我们知道，当一个可观测对象的属性被读写时，会触发它的getter/setter方法。换个思路，如果我们可以在可观测对象的getter/setter里面，去执行监听器里面的onComputedUpdate()方法，是不是就能够实现让对象主动发出通知的功能呢？ 由于监听器内的onComputedUpdate()方法需要接收回调函数的值作为参数，而可观测对象内并没有这个回调函数，所以我们需要借助一个第三方来帮助我们把监听器和可观测对象连接起来。 这个第三方就做一件事情——收集监听器内的回调函数的值以及onComputedUpdate()方法。 现在我们把这个第三方命名为“依赖收集器”，一起来看看应该怎么写： const Dep = { target: null } 就是这么简单。依赖收集器的target就是用来存放监听器里面的onComputedUpdate()方法的。 定义完依赖收集器，我们回到监听器里，看看应该在什么地方把onComputedUpdate()方法赋值给Dep.target： function watcher (obj, key, cb) { // 定义一个被动触发函数，当这个“被观测对象”的依赖更新时调用 const onDepUpdated = () =&gt; { const val = cb() onComputedUpdate(val) } Object.defineProperty(obj, key, { get () { Dep.target = onDepUpdated // 执行cb()的过程中会用到Dep.target， // 当cb()执行完了就重置Dep.target为null const val = cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } 我们在监听器内部定义了一个新的onDepUpdated()方法，这个方法很简单，就是把监听器回调函数的值以及onComputedUpdate()给打包到一块，然后赋值给Dep.target。这一步非常关键，通过这样的操作，依赖收集器就获得了监听器的回调值以及onComputedUpdate()方法。作为全局变量，Dep.target理所当然的能够被可观测对象的getter/setter所使用。 重新看一下我们的watcher实例： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) 在它的回调函数中，调用了英雄的health属性，也就是触发了对应的getter函数。理清楚这一点很重要，因为接下来我们需要回到定义可观测对象的defineReactive()方法当中，对它进行改写： function defineReactive (obj, key, val) { const deps = [] Object.defineProperty(obj, key, { get () { if (Dep.target &amp;&amp; deps.indexOf(Dep.target) === -1) { deps.push(Dep.target) } return val }, set (newVal) { val = newVal deps.forEach((dep) =&gt; { dep() }) } }) } 可以看到，在这个方法里面我们定义了一个空数组deps，当getter被触发的时候，就会往里面添加一个Dep.target。回到关键知识点Dep.target等于监听器的onComputedUpdate()方法，这个时候可观测对象已经和监听器捆绑到一块。任何时候当可观测对象的setter被触发时，就会调用数组中所保存的Dep.target方法，也就是自动触发监听器内部的onComputedUpdate()方法。 至于为什么这里的deps是一个数组而不是一个变量，是因为可能同一个属性会被多个计算属性所依赖，也就是存在多个Dep.target。定义deps为数组，若当前属性的setter被触发，就可以批量调用多个计算属性的onComputedUpdate()方法了。 完成了这些步骤，基本上我们整个响应式系统就已经搭建完成，下面贴上完整的代码： /** * 定义一个“依赖收集器” */ const Dep = { target: null } /** * 使一个对象转化成可观测对象 * @param { Object } obj 对象 * @param { String } key 对象的key * @param { Any } val 对象的某个key的值 */ function defineReactive (obj, key, val) { const deps = [] Object.defineProperty(obj, key, { get () { console.log(`我的${key}属性被读取了！`) if (Dep.target &amp;&amp; deps.indexOf(Dep.target) === -1) { deps.push(Dep.target) } return val }, set (newVal) { console.log(`我的${key}属性被修改了！`) val = newVal deps.forEach((dep) =&gt; { dep() }) } }) } /** * 把一个对象的每一项都转化成可观测对象 * @param { Object } obj 对象 */ function observable (obj) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i], obj[keys[i]]) } return obj } /** * 当计算属性的值被更新时调用 * @param { Any } val 计算属性的值 */ function onComputedUpdate (val) { console.log(`我的类型是：${val}`) } /** * 观测者 * @param { Object } obj 被观测对象 * @param { String } key 被观测对象的key * @param { Function } cb 回调函数，返回“计算属性”的值 */ function watcher (obj, key, cb) { // 定义一个被动触发函数，当这个“被观测对象”的依赖更新时调用 const onDepUpdated = () =&gt; { const val = cb() onComputedUpdate(val) } Object.defineProperty(obj, key, { get () { Dep.target = onDepUpdated // 执行cb()的过程中会用到Dep.target， // 当cb()执行完了就重置Dep.target为null const val = cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } const hero = observable({ health: 3000, IQ: 150 }) watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) console.log(`英雄初始类型：${hero.type}`) hero.health = 5000 // -&gt; 我的health属性被读取了！ // -&gt; 英雄初始类型：脆皮 // -&gt; 我的health属性被修改了！ // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：坦克 上述代码可以直接在code pen点击预览或者浏览器控制台上执行。 四、代码优化在上面的例子中，依赖收集器只是一个简单的对象，其实在defineReactive()内部的deps数组等和依赖收集有关的功能，都应该集成在Dep实例当中，所以我们可以把依赖收集器改写一下： class Dep { constructor () { this.deps = [] } depend () { if (Dep.target &amp;&amp; this.deps.indexOf(Dep.target) === -1) { this.deps.push(Dep.target) } } notify () { this.deps.forEach((dep) =&gt; { dep() }) } } Dep.target = null 同样的道理，我们对observable和watcher都进行一定的封装与优化，使这个响应式系统变得模块化： class Observable { constructor (obj) { return this.walk(obj) } walk (obj) { const keys = Object.keys(obj) keys.forEach((key) =&gt; { this.defineReactive(obj, key, obj[key]) }) return obj } defineReactive (obj, key, val) { const dep = new Dep() Object.defineProperty(obj, key, { get () { dep.depend() return val }, set (newVal) { val = newVal dep.notify() } }) } } class Watcher { constructor (obj, key, cb, onComputedUpdate) { this.obj = obj this.key = key this.cb = cb this.onComputedUpdate = onComputedUpdate return this.defineComputed() } defineComputed () { const self = this const onDepUpdated = () =&gt; { const val = self.cb() this.onComputedUpdate(val) } Object.defineProperty(self.obj, self.key, { get () { Dep.target = onDepUpdated const val = self.cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } } 然后我们来跑一下： const hero = new Observable({ health: 3000, IQ: 150 }) new Watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }, (val) =&gt; { console.log(`我的类型是：${val}`) }) console.log(`英雄初始类型：${hero.type}`) hero.health = 5000 // -&gt; 英雄初始类型：脆皮 // -&gt; 我的类型是：坦克]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>computed</tag>
        <tag>响应式</tag>
        <tag>数据绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Vue Router是Vue.js的官方路由器。它与Vue.js核心深度集成，使用Vue.js构建单页应用程序变得轻而易举。 使用步骤 引入vue-router对象 安装插件：Vue.use(VueRouter) 创建一个路由对象 var router = new VueRouter（{routes：[]}） 配置路由对象 :routes:[{path:’/login/:name’,component:xx} ] 将配置好的路由对象关联到事列中:router:router 指定路由改变局部的位置:router-link ：to=‘’ 查询字符串 配置：to =“{name:’detail’,query:{id:hero.id} }” 规则：{name：‘detail’,path:’/detail’,component:Detail} 获取：this.$route.query.id 生成： path方式 配置：to =“{name:’detail’,params:{id:hero.id} }” 规则：{name：‘detail’,path:’/detail’/ :id} 获取：this.$route.params.id 生成：path方式需要在路由规则中声明位置 vue-router中的对象 $route路由信息对象，只读对象 $router路由操作对象，只写对象 嵌套路由单页面应用开发多页面的路由。多个组件按不同的锚点值填入不同的位置使用规则： router-view中包含router-view 路由规则中存在子路由 辅助知识点 路由meta元数据—-meta对于路由规则是否需要验证权限的配置,路由对象中和name属性同级 {meta：{isChecked：true}} 路由钩子—权限控制的函数执行时期 每次路由匹配后，渲染组件到router-view之前 router.beforeEach(function(to,from,next){ }):next()直接放行，next(){}跳转到相应的路由]]></content>
      <categories>
        <category>Vue知识点总结</category>
      </categories>
      <tags>
        <tag>路由，vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础知识点]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[基础知识点框架与库的区别jquery库+DOM操作+http请求 = 全家桶 如何起步 引包Vue.js 通过Vue对象，new Vue（options） 配置options对象 el:发生动作的目的地 template:模板（必须为一个根节点） data函数，返回的是一个对象 components:key是组件名，value是组件对象 methods：配合事件 props：子组件接受的参数设置 插值表达式：对象、字符串、判断后的布尔值、三元表达式#### 常用指令 - v-text:元素的innerText属性 - v-html：元素的innerHTML属性 - v-if:判断是否插入，v-else-if，v-else和v-if必须是相邻的元素 - v-show:隐藏元素，给元素加上display：none - v-bind:绑定属性，单向数据流,v-bind:属性=‘变量’ 简写：属性名=‘xxx’ - v-model：双向数据绑定，v-on:事件名=‘函数’ 简写： @事件名 - v-on:绑定事件，处理自定义原生事件，v-on:事件名=“表达式 ||函数名 ” - v-for:循环 用法：v-for=“item in stus” 如果stus为数组，（item，index） in stus 如果stus为obj，（value,key,index） in stus#### 全局组件场景：公共性功能组件，减少冗余代码全局API：Vue.component(‘组件名’，组件对象)#### 过滤器给数据的显示进行操作，如反转，改变属性等filter：全局过滤器，Vue.filter(‘过滤器名’，过滤方式fun)filters：组件内的过滤器，Vue.filters(‘过滤器名’，过滤方式fun)，使用:内容 | 过滤器名#### watch监视单个属性改变，无法监视复杂类型，因为监视的是对象地址，地址没有改变，改变的只是属性#### computed监视多个：object | array computed：{ 监视的业务名:function(){}} 使用： slotvue内置的组件，父组件向子组件传DOM结构，而props是动态的数据，如果有选择性传递，就具名插槽，以name来选择，使用的对应的slot=name值即可 组件生命周期所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 beforeCreate：组件创建之前，拿不到数据 created:可以操作数据，并且可以实现vue-&gt;页面的额影响，用于发起http请求 beforeMount：vue起作用，装载数据到DOM之前，应用：vue启动前的DOM mounted：vue起作用，装载数据到DOM之前，应用：vue启动后的DOM，仅执行一次 beforeUpdate:基于数据的改变才会触发，数据改变之前，应用：获取原DOM updated：基于数据的改变才会触发，数据改变之后,应用：获取新DOM beforeDestroy：销毁前，做一些功能的释放，如本地保存 destroyed：销毁后 activated：激活 deactivated：停用 小结：频繁的销毁和创建组件？不合理，使用keep_alive内置组件包裹起来，对应的是actived和deactived声明周期；created和actived：都是子组件状态，created没有被keep-alive内置组件包括，actived被包裹； 获取DOM元素在组件的DOM部分任意标签写上ref=”xxx”,通过组件对象，this.$refs.xxx获取到元素]]></content>
      <categories>
        <category>Vue知识点总结</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>指令</tag>
        <tag>生命周期 ，组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2018]]></title>
    <url>%2F2018%2F12%2F30%2F%E6%88%91%E7%9A%842018%2F</url>
    <content type="text"><![CDATA[前言感觉今年过的很快，其实回头看看经历了很多很多。在2018的尾巴上，回顾这一年的经历，只为明年做的更好。 回首过去关于学习这一年，教研室从一楼搬到了五楼，搬砖的工作量也相应的随楼层的增加而增加。前前后后忙了两个项目，主要的技术栈是bootstrap、Vue、elementUI、webpack等开发工具，那段时间很忙，很头疼，因为没有前辈指导，所有踩的坑都得一个一个一遍又一遍的踩，却感觉很充实，那段时间是自己知识积累最快的一个阶段了吧。后面的一段时间自学了小程序，自己也开发了一个小程序、因审核内容受限、所以没上线。方向是好的，自己可以拿来练练手。12月，联系了一个前辈、打算慢慢参与开源，虽然目前来说是一些维护的事，但也好在为来年的计划做点铺垫。其他方面，学会了烘培、拉花、做咖啡，学会了游泳，也尝试了未曾尝试过的菜肴。 关于秋招秋招算是自己沉淀知识的阶段，年初买的红皮书、权威指南等前端方面的书籍也在秋招的时候看了个遍。过程总的来说很幸运也很遗憾，幸运的是在6月就拿了一个研究所的offer，心里也不是特别的慌；遗憾的是因错过阿里三面的电话而失之交臂，投提前批，找内推就如同石沉大海，没有回应。后面去上海参加上汽举行的“摩尔100计划”，也算散心了，运气也好了起来，最后拿到的offer中，有高薪资的、有发展好的，没有选择最高薪资的、也没有选择发展最好的，而是选择了自己觉得最适合的公司吧。对于秋招的总结，大概就是以下几点： 基础知识要扎实，特别是css，js方面。 在js方面，不仅要有基础，更要有深度。 框架方面，不能只会用，更要了解原理，深入源码 工程方面，要考虑到网络通信、上线bug、维护的问题。 知识的广度，不能局限在前端，后台、安全也很重要。 要有大前端的思想，不能局限在一个模子里面。 关于毕设作为一个前端开发，毕设做人脸识别也算是一种挑战，当找完工作回归教研室看我的开题报告的时候，我第一反应这谁的毕设？谁写的开题报告？我为啥做这个？典型的灵魂三问，然而我不知道系列。疯狂的看英文文献，找创新点，标数据集，训练模型，路途还很遥远，壮士还需努力啊。 关于健身2018年参加了人生第一场正式的马拉松、没有想象中那么难、只是需要坚持下去就好了，路途中有很多让我很感动的风景：单腿带着拐杖走的人，年过七旬的人，坐在轮椅里的人，带着小孩坚持走的人；你会发现，比你优秀的、没你生来完善的人都在努力坚持着自己的生活、你还有什么理由不努力呢？2018年坚持健身的又一年，很庆幸自己没有理由的坚持了下来并养成了习惯，因为是阳光的、美好的，所以更想去坚持吧。 关于旅行18年去的地方不多也不少，时常怀念自己大学毕业义工旅行的日子，真正做到随遇而安的小安，开了属于自己的民宿的露露，她们都走上了自己喜欢的那条路。对于旅行，我一直是坚持的，在路上的。这一年徒步了白雪皑皑的四人同、带老妈小弟逛了成都、打卡了上海、自驾了川西大环线，又一次去了色达，遇见了稻城，更遇见了自己。 展望未来保持对生活的热情，保持内心的孩子气，做自己想做的事情，无论生活变成什么样子，可以受苦，可以跌倒，可以失落，但是不能当废柴。努力做好下面的： 因上努力，果上随缘 好好学习，顺利毕业 多多读书，坚持阅读 努力工作，尽早适应 参与开源，多看源码 做好总结，及时更博 坚持锻炼，坚持健身 做好理财，出去旅行 自爱沉稳，而后爱人 都说2019年属猪的一年，肯定不缺肉吃。我想我的2019年，少点焦虑，多点自律。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阮一峰ES6之Promise对象的理解]]></title>
    <url>%2F2018%2F12%2F30%2F%E9%98%AE%E4%B8%80%E5%B3%B0ES6%E4%B9%8BPromise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、Promise的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象的特点（1）对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来“承若”；（2）一旦状态改变就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。二、用法创建一个实例： const promise = new Promise(function(resolve,reject){ //some code if(//异步操作成功){ resolve(value); }else{ reject(error); } });Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。Promise 新建后就会立即执行。 let promise = new Promise(function(resolve, reject) { console.log(‘Promise’); resolve(); }); promise.then(function() { console.log(‘resolved.’); }); console.log(‘Hi!’); 执行结果：上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 // Promise // Hi! // resolved下面是一个用Promise对象实现的 Ajax 操作的例子。 const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(“GET”, url); client.onreadystatechange = handler; client.responseType = “json”; client.setRequestHeader(“Accept”, “application/json”); client.send(); }); return promise; }; getJSON(“/posts.json”).then(function(json) { console.log(‘Contents: ‘ + json); }, function(error) { console.error(‘出错了’, error); });上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。如果调用resolve函数和reject函数时带有参数，那么他们的参数会被传递给回调函数，reject函数的参数通常是Error对象的实例，表示抛出的错误，resolve函数的参数除了正常的值以外，还可以是另一个promise实例； var p1 = new Promise(function (resolve, reject) { // … }); var p2 = new Promise(function (resolve, reject) { // … resolve(p1); }) p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。三、Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(“/posts.json”).then(function(json) { return json.post; }).then(function(post) { // … });上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。四、Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 getJSON(‘/posts.json’).then(function(posts) { // … }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(‘发生错误！’, error); });上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。五、Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]);上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。下面是一个具体的例子。 // 生成一个Promise对象的数组 const promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(‘/post/‘ + id + “.json”); }); Promise.all(promises).then(function (posts) { // … }).catch(function(reason){ // … });上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。下面是另一个例子。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result) .catch(e =&gt; e); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result) .catch(e =&gt; e); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // [“hello”, Error: 报错了]上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // Error: 报错了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流与去抖]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E6%8A%96%2F</url>
    <content type="text"><![CDATA[####使用场景以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。 window对象的resize、scroll事件 拖拽时的mousemove事件 射击游戏中的mousedown、keydown事件 文字输入、自动完成的keyup事件 实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的0执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。 ####debounce抖动：如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。接口定义： /** * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行 * @param idle {number} 空闲时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ debounce(idle,action) 简单实现1：利用定时器，让函数执行延迟500毫秒，在500毫秒内如果有函数又被调用则删除上一次调用，这次调用500毫秒后执行，如此往复 window.onscroll = function(){//lazyload(); debounce(lazyload,window); }; function debounce(method,context){ clearTimeout(method.timeout); method.timeout = setTimeout(function(){ method.call(context); },500); } function lazyload(){ console.log(&quot;scroll执行了&quot;+scrollnum); } 简单实现2： 还有一种节流方式，是通过返回闭包的形式，可以设置延迟时间，两者运行的结果是一样，但是我在实际操作的时候设置延迟500时，滚动过了一会才执行了,设置为delay为100的时候在视觉上就没有感觉延迟。而且函数也只滚动了一次。 function debounce1(method,delay){ var timer = null; return function(){ var context = this,args = arguments; clearTimeout(timer); timer = setTimeout(function(){ method.apply(context,args); },delay); } } ####throttle当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了(对于实现keyup事件的提示也没有意义了)，所以可以为函数添加一个参数作为到固定间隔必须执行，到了这个时间间隔就必须执行，这个时候就引入了节流： 节流：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期接口定义： /** * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay * @param delay {number} 延迟时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ throttle(delay,action) 简单实现： var throttle = function(delay, action){ var last = 0; return function(){ var curr = +new Date(); if (curr - last &gt; delay){ action.apply(this, arguments); last = curr ; } } } 简单实现2： function throttle2(method, delay, time) { var timeout,startTime = new Date(); return function() { var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout);// 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) { method.apply(context, args); startTime = curTime;//没达到触发间隔，重新设定定时器 } else { timeout = setTimeout(method, delay); } };]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之this的指向理解]]></title>
    <url>%2F2018%2F12%2F29%2FJS%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.this是什么？ this是对象自动生成的一个内部对象，是在运行时基于函数的执行环境绑定的，因为函数的调用场合不同，this的值也有变化。this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时 。这句话目前也只能说在ES5中才是正确的，而在ES6的箭头函数中，this的指向就是在定义的时候就确定的。 2. this的绑定规则this的绑定总共差不多有下面五种： 默认绑定 隐式绑定 显示绑定 new绑定 ES6箭头函数中的this2.1.默认绑定12345function foo()&#123; console.log(this.a); // 10&#125;var a = 10;foo(); 作为独立函数的调用，this指向的是全局对象window，而在严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。 2.2.隐式绑定123456789function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;foo(); //undefinedobj.foo(); // 2 foo() 这个就是默认绑定,等价于打印 window.a ,故输出 undefined ；obj.foo()，函数有上下文对象，即obj，这种情况下， 函数里的this默认绑定为上下文对象 ，等价于打印 obj.a ,故输出2 。如果是链性的关系，比如 xx.yy.obj.foo(); , 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。再看下一个情况：12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数别名var a =,10; // a是全局对象的属性bar(); // 10 虽然bar为obj.foo的引用，但实际上引用的是foo函数本身，此时this指向为默认绑定，指向的window，所以输出10 2.3.显示绑定 显示绑定就是call apply bind，call和apply它们的作用都是改变函数的this指向 ， 第一个参数都是 设置this对象 。两个函数的区别：call从第二个参数开始所有的参数都是 原函数的参数。apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。1234567function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 调用foo时强制把foo的this绑定到obj上 bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回。123456function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 10 &#125;;foo = foo.bind(obj);foo(); // 10 2.4.new绑定js中的只要用new修饰的 函数就是’构造函数’，准确来说是 函数的 构造调用 ，因为在js中并不存在所谓的’构造函数’。那么用new 做到函数的 构造调用 后，js帮我们做了什么工作呢: 1234567function createNew() let obj = new Object() // 创建一个空的对象 let Con = [].shift.call(arguments) // 获得构造函数 obj.__proto__ = Con.prototype // 链接到原型 let result = Con.apply(obj, arguments) // 绑定 this，执行构造函数 return typeof result === &apos;object&apos; ? result : obj // 确保 new 出来的是个对象&#125; 1、创建（或者说构造）一个新对象。2、这个新对象会被执行[[Prototype]]连接。3、这个新对象会绑定到函数调用的this。4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 12345678function foo()&#123; this.a = 10; console.log(this);&#125;foo(); // window对象console.log(window.a); // 10 默认绑定var obj = new foo(); //// 等价于 foo &#123; a : 10 &#125;; var obj = foo; console.log(obj.a); // 10 new绑定 特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例: function foo(){ this.a = 10; return new String(&quot;啊哈哈&quot;); } var obj = new foo(); console.log(obj.a); // undefined console.log(obj); // &quot;啊哈哈&quot; 2.5 ES6箭头函数中的thisfoo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。12345678910111213function foo() &#123; return (a) =&gt; &#123; //返回一个箭头函数 console.log( this.a ); // this继承自foo() &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;var bar = foo.call( obj1 );bar.call( obj2 ); // 2，不是3！ 3. 优先级new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 4. 总结1.如果函数是在某个 上下文对象 下被调用：this绑定的是那个上下文对象，例 : var obj = { foo : foo }; obj.foo(); foo 中的 this 就是 obj2.如果函数是使用 call,apply,bind 来调用的：this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj3.如果函数被 new 修饰：this绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar4.如果都不是，则是默认绑定 5.常见题目分析var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); // 20 //隐式绑定,this指向上下文obj var foo = function(){ console.log(this.x); } foo(); //10 默认绑定 指向的是window对象 } }; obj.f(); 12345678function foo(arg)&#123; this.a = arg; return this&#125;;var a = foo(1);var b = foo(10);console.log(a.a); // ?undefinedconsole.log(b.a); // ?10 分析：foo(1)执行，应该不难看出是默认绑定吧 , this指向了window，函数里等价于 window . a = 1,return window;var a = foo(1) 等价于 window . a = window , 很多人都忽略了 var a 就是window.a ，将刚刚赋值的 1 替换掉了。所以这里的 a 的值是 window , a . a 也是window ， 即window . a = window ; window . a . a = window;foo(10) 和第一次一样，都是默认绑定，这个时候， 将window.a 赋值成 10 ，注意这里是关键，原来window.a = window ,现在被赋值成了10，变成了值类型，所以现在 a.a = undefined。(验证这一点只需要将var b = foo(10);删掉，这里的 a.a 还是window)var b = foo(10); 等价于 window.b = window;本题中所有变量的值，a = window.a = 10 , a.a = undefined , b = window , b.a = window.a = 10; 1234567891011121314151617181920var num = 1;var myObject = &#123; num: 2, add: function() &#123; this.num = 3; (function() &#123; console.log(this.num); //默认绑定 指向的window 输出1 this.num = 4; &#125;)(); console.log(this.num); &#125;, sub: function() &#123; console.log(this.num) &#125;&#125;myObject.add(); console.log(myObject.num); console.log(num);var sub = myObject.sub;sub(); 依次输出 1 3 3 4 4]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈我对vuex的理解]]></title>
    <url>%2F2018%2F12%2F29%2F%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Vuex%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在近期做得项目中，用到Vue框架，必不可少的也用到vuex状态管理，再加上面试中也被问到了，索性把这一块拿出来抽时间整理一下： 核心概念Vuex 是适用于 Vue.js 应用的状态管理库，为应用中的所有组件提供集中式的状态存储与操作，保证了所有状态以可预测的方式进行修改。官网的一张图： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，重新渲染Vue Components，界面随之更新 完整流程 单向数据流规定所有的数据操作必须通过 action – mutation – state change 的流程来进行，再结合Vue的数据视图双向绑定特性来实现页面的展示更新 state单一状态树那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： // 创建一个 Counter 组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return store.state.count } } } 然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： const app = new Vue({ el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; ` }) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from &apos;vuex&apos; export default { computed: mapState({ count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：而且Mutation必须为同步函数当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：store.commit(‘increment’) const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) ActionAction 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(&apos;increment&apos;) } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 分发 ActionAction 通过 store.dispatch 方法触发：store.dispatch(‘increment’)在组件中分发 Action:在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： import { mapActions } from &apos;vuex&apos; export default { methods: { ...mapActions([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` // `mapActions` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` ]), ...mapActions({ add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` }) }}]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
</search>
