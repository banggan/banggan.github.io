<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue源码解读之基础前言]]></title>
    <url>%2F2019%2F01%2F05%2FVue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言从开始学习Vue到现在也有1年半了吧，以后的工作也是大部分的Vue相关，为了打好基础，方便迎接年后Vue3.0，给自己定了一个计划-有针对性的读源码并做一个系列的总结。 Flow静态检测Vue.js 的源码利用了 Flow 做了静态类型检查，所以要对flow有一定的了解诶啊在 Vue.js 的主目录下有 .flowconfig 文件， 它是 Flow 的配置文件，感兴趣的同学可以看官方文档。这其中的 [libs] 部分用来描述包含指定库定义的目录，默认是名为 flow-typed 的目录。这里 [libs] 配置的是 flow，表示指定的库定义都在 flow 文件夹内。我们打开这个目录，会发现文件如下： flow ├── compiler.js # 编译相关 ├── component.js # 组件数据结构 ├── global-api.js # Global API 结构 ├── modules.js # 第三方库定义 ├── options.js # 选项相关 ├── ssr.js # 服务端渲染相关 ├── vnode.js # 虚拟 node 相关 Vue源码目录在git上下载Vue的源码，可以看到src的子目录如下： src ├── compiler # 编译相关 ├── core # 核心代码 ├── platforms # 不同平台的支持，有web+weex ├── server # 服务端渲染 ├── sfc # .vue 文件解析 ├── shared # 共享代码 Vue源码构建Vue.js 源码是基于 Rollup 构建的，它的构建相关配置都在 scripts 目录下。通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件，它的内容实际上是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下： { &quot;script&quot;: { &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;build:ssr&quot;: &quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;, &quot;build:weex&quot;: &quot;npm run build --weex&quot; } } 先打开构建的入口 JS 文件，在 scripts/build.js 中：这段代码逻辑非常简单，先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。1234567891011121314let builds = require(&apos;./config&apos;).getAllBuilds()// filter builds via command line argif (process.argv[2]) &#123; const filters = process.argv[2].split(&apos;,&apos;) builds = builds.filter(b =&gt; &#123; return filters.some(f =&gt; b.output.file.indexOf(f) &gt; -1 || b._name.indexOf(f) &gt; -1) &#125;)&#125; else &#123; // filter out weex builds by default builds = builds.filter(b =&gt; &#123; return b.output.file.indexOf(&apos;weex&apos;) === -1 &#125;)&#125;build(builds) Vue入口import Vue from ‘./runtime/index’ 定义Vue的入口，那Vue是如何被定义的呢？123import Vue from &apos;core/index&apos; //重点！重点引入代码.........export default Vue 在core中的index代码如下：123456789import Vue from &apos;./instance/index&apos; //重点 引入Vue定义代码import &#123; initGlobalAPI &#125; from &apos;./global-api/index&apos;initGlobalAPI(Vue) // 重点！！1！初始化全局的APIObject.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123; get: isServerRendering&#125;)........export default Vue Vue 的真实定义：终于看到了 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，我们只能通过 new Vue 去实例化它。 import { initMixin } from &apos;./init&apos; import { stateMixin } from &apos;./state&apos; import { renderMixin } from &apos;./render&apos; import { eventsMixin } from &apos;./events&apos; import { lifecycleMixin } from &apos;./lifecycle&apos; import { warn } from &apos;../util/index&apos; function Vue (options) { if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue) ) { warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) } this._init(options) } initMixin(Vue) stateMixin(Vue) eventsMixin(Vue) lifecycleMixin(Vue) renderMixin(Vue) export default Vue initGlobalAPI：Vue.js 在整个初始化过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 src/core/global-api/index.js 中： 123456789101112131415161718192021222324252627282930313233export function initGlobalAPI (Vue: GlobalAPI) &#123; // config const configDef = &#123;&#125; configDef.get = () =&gt; config if (process.env.NODE_ENV !== &apos;production&apos;) &#123; configDef.set = () =&gt; &#123; warn( &apos;Do not replace the Vue.config object, set individual fields instead.&apos; ) &#125; &#125; Object.defineProperty(Vue, &apos;config&apos;, configDef) Vue.util = &#123; warn, extend, mergeOptions, defineReactive &#125; Vue.set = set Vue.delete = del Vue.nextTick = nextTick Vue.options = Object.create(null) ASSET_TYPES.forEach(type =&gt; &#123; Vue.options[type + &apos;s&apos;] = Object.create(null) &#125;) Vue.options._base = Vue extend(Vue.options.components, builtInComponents) initUse(Vue) initMixin(Vue) initExtend(Vue) initAssetRegisters(Vue)&#125;]]></content>
      <categories>
        <category>Vue源码解读</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>源码，Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像格式的区别以及应用场景]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[在实际的开发中，遇到了这个问题，有点理不清，特来整理一次： jpg格式全名应该是JPEG。JPEG 图片以 24 位颜色存储单个光栅图像。JPEG 是与平台无关的格式，支持最高级别的压缩，不过，这种压缩是有损耗的。渐近式JPEG文件支持交错。可以提高或降低 JPEG文件压缩的级别。但是，文件大小是以图像质量为代价的。压缩比率可以高达 100:1。（JPEG 格式可在 10:1 到 20:1 的比率下轻松地压缩文件，而图片质量不会下降。）JPEG压缩可以很好地处理写实摄影作品。但是，对于颜色较少、对比级别强烈、实心边框或纯色区域大的较简单的作品，JPEG 压缩无法提供理想的结果。有时，压缩比率会低到5:1，严重损失了图片完整性。这一损失产生的原因是，JPEG 压缩方案可以很好地压缩类似的色调，但是 JPEG 压缩方案不能很好地处理亮度的强烈差异或处理纯色区域。Jpeg格式特点： 透明性：它不支持透明性 动画：它不支持动画 损耗性：除了一些比如说（仅仅是90、180、270度旋转），裁切，从标准类型到先进类型，编辑图片的原数据之外，所有其它操作对jpeg图像的处理都会使得它的质量损失，所以我们在编辑过程一般用png作为过渡格式。 隔行渐进显示，它支持隔行渐进显示（但是ie浏览器并不支持这个属性，但是ie会在整个图像信息完全达到的时候显示）。由上可以看出Jpeg是最适web上面的摄影图片和数字照相机中。根据惊叹我们在页面中使用的商品图片、采用人像或者好、实物素材制作的广告更适合采用JPG格式保存。gif格式GIF(GraphicsInterchange Format)的原义是“图像互换格式”，是CompuServe公司在 1987年开发的图像文件格式。GIF文件的数据，是一种基于LZW算法的连续色调的无损压缩格式。其压缩率一般在50％左右，它不属于任何应用程序。目前几乎所有相关软件都支持它，公共领域有大量的软件在使用GIF图像文件。GIF图像文件的数据是经过压缩的，而且是采用了可变长度等压缩算法。所以GIF的图像深度从lbit到8bit，也即GIF最多支持256种色彩的图像。GIF格式的另一个特点是其在一个GIF文件中可以存多幅彩色图像，如果把存于一个文件中的多幅图像数据逐幅读出并显示到屏幕上，就可构成一种最简单的动画。gif 格式特点： 透明性：gif是一种布尔透明类型，即它可以使全透明，也可是全不透明，但是它并没有半透明的（alpha透明）。 动画：gif格式支持动画。 无损耗性：gif是一种无损耗的图像格式，这也意味着你可以对gif图片做任何操作也不会使得图像质量产生损耗。 水平扫描：gif是使用一种叫做LZW的算法进行压缩的，当压缩gif的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的gif图片比竖向的gif更加小。例如50010的图片比10500的图片更加小。 间隔渐进显示：gif支持可选择性的间隔渐进显示。由以上特点看出只有256种颜色的gif图片不适合照片，但它适合对颜色要求不高的图形（比如说图标、图表等）。png格式PNG是20世纪90年代中期开始开发的图像文件存储格式，其目的是企图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。流式网络图形格式(Portable Network Graphic Format，PNG)名称来源于非官方的“PNG’s NotGIF”，是一种位图文件(bitmapfile)存储格式，读成“ping”。PNG用来存储灰度图像时，灰度图像的深度可多到16位，存储彩色图像时，彩色图像的深度可多到48位，并且还可存储多到16位的α通道数据。PNG使用从LZ77派生的无损数据压缩算法Png格式特点： 类型：Png这种图片格式包括了许多类，但是在实践的大致中可以分为256色的png和全色的png，你完全可以用256色的png代替gif，用全色的png代替jpeg。 透明性：png是完全支持alpha透明的（透明、半透明、不透明），尽管有两个怪异的现象在ie6（下面详细讨论） 动画：它不支持动画Png8的在ie中的怪异表现：半透明的png8在ie6以下的浏览器显示为全透明。alpha透明的全色PNG（png32）在ie6中会出现背景颜色（通常是灰色）上面可以总结：全透明的png8可以在任一浏览器正常显示（就像gif一样）。半透明的png8在除了ie6及其一下的浏览器下错误的显示成全透明，其它的浏览器都能正常显示半透明。图像上颜色较少、并且主要以纯色或者平滑的渐变色填充以及具备较大的亮度差异的图像适合以png8格式存储。svg格式可缩放矢量图形是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式。它由万维网联盟制定，是一个开放标准。SVG格式特点： SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM和 XSL 之类的W3C标准是一个整体SVG跟上面这些图片格式最大的不同，是SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。 bmp格式BMP是一种与硬件设备无关的图像文件格式，使用非常广。它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，因此，BMP文件所占用的空间很大。BMP文件的图像深度可选lbit、4bit、8bit及24bit。BMP文件存储数据时，图像的扫描方式是按从左到右、从下到上的顺序。这是一种比较老的图片格式。BMP是无损的，但同时这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。虽然同时支持索引色和直接色是一个优点，但是太大的文件格式格式导致它几乎没有用武之地，现在除了在Windows操作系统中还比较常见之外，我们几乎看不到它。WebP格式WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。想象Web上的图片之多，百分之几十的提升，是非常非常大的优化。只可惜，目前只有Chrome浏览器和Opera浏览器支持WebP格式，所以WebP的应用并不广泛。为了使用更先进的技术，比如WebP图片格式，来压缩互联网上传输的数据流量，谷歌甚至提供了Chrome Data Compression Proxy，设置了Chrome Data Compression Proxy作为Web代理之后，你访问的所有网站中的图片，在经过Proxy的时候，都会被转换成WebP格式，以降低图片文件的大小。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。]]></content>
      <categories>
        <category>图像格式</category>
      </categories>
      <tags>
        <tag>图像格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios总结]]></title>
    <url>%2F2019%2F01%2F04%2Faxios%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。在Vue中常用axios来做前后端的交互；上一张git上的star值 特点 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 使用安装：$ npm install axios cdn方式： src=”https://unpkg.com/axios/dist/axios.min.js&quot;基本使用：123Axios.method(&apos;url&apos;,[...data],options).then(function(res)&#123;&#125;).catch(function(err)&#123;&#125;) 合并请求：12345678910111213例如：//定义两个不不同的情请求var q1 =this.axio.get（‘url’)var q2= this.post(&apos;url&apos;,&apos;a=1&apos;)//合并q1,q2请求this.$axios.all([q1,q2]).then(this.$axios.spread((res1,res2)=&gt;&#123; //全成功 this.res1=res1; this.res1=res1;&#125;)).catch(err=&gt;&#123; //只要其中一个失败 console.log(err); &#125;) 配置公共信息： this.$ axios.defaults.baseURL = ‘http://sss/ss/s’ options参数还可以为params查询字符串对象；transformRequest转换请求体数据；headers请求头信息；data请求数据，timeout请求超时场景：所有请求自带的头信息 this.$axios.headers ={};// 覆盖原本默认的头部 this.$ axios.defaults.headers.accept =&apos;abc&apos;//修改个别信息即可 没有使用箭头函数的时候，一定要注意作用域的问题，如上诉代码的that登录的安全机制 xsrfCookieName服务器返回一个xsrf-token令牌，保存起来 xsrfHeaderName 请求自动携带x-xsrf-token=xxx 取消请求 断点续传取消请求 场景：在上传文件的时候，用户发现去、文件错误取消请求123456789101112131415161718const CancelToken = axios.CancelToken;const source = CancelToken.source(); //创建标志请求的源对象axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token // 携带取消的标志 &#125;).catch(function (thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // handle error &#125;&#125;);axios.post(&apos;/user/12345&apos;, &#123; name: &apos;new name&apos;&#125;, &#123; cancelToken: source.token // 携带取消的标志&#125;)source.cancel(&apos;Operation canceled by the user.&apos;); // 取消导致之前的请求 断点续传 场景：文件上传被中断,需要续传 及时获取到已经上传的部分，保存已上传部分： this.loaded = progressEvent.loaded 剪裁文件： this.loaded = progressEvent.loaded // 获取已经上传的部分 var fileData = this.file.slice(this.loaded +1 , this.file,size) //裁剪文件 var fd = new FormData(); fd.append(&apos;file&apos;,fileData); //后续未上传的文件 const CancelToken = axios.CancelToken; const source = CancelToken.source(); this.axios.post(&apos;url&apos;,fd,{ cancelToken: source.token // 携带取消的标志 //处理事件 }) 拦截器 请求拦截器：发起请求之前做的事 响应拦截器：响应回来之后做的事 应用场景1：在请求发起之前，展示一个loading,在响应回来之后，关闭一个loading123456789101112131415161718send:function()&#123;//配置拦截器//use给请求之前做的事可是是多件，可以use很多次this.$ axios.interceptors.request.use(function(config)&#123; console.log(config); return config;&#125;);//响应拦截器this.$ axios.interceptors.reponse.use(function(res)&#123; console.log(res.config); this.isShow = true; //在请求发起之前，展示一个loading return res.config;&#125;);this.$ axios.get(&apos;url&apos;).then(res=&gt;&#123; console.log(&apos;响应回来&apos;,res) this.isShow = false; //在响应回来之后，关闭一个loading&#125; 应用场景2：实现一个类似的cookie机制服务器 —-设置set-cookie:xxx 保存起来在响应中完成在请求之前，本地获取xxx,设置拦截器，请求头 123456789101112131415161718sendAjax:function()&#123; // 请求拦截器 this.$axios.interceptors.request.use((config)=&gt;&#123; var token = localStroage.getItem(&apos;token&apos;); // 设置请求头，类似cookie if（token）&#123; config.headers[&apos;token&apos;] = token ; &#125; this.isShow = true; return res.config; &#125;） // 响应拦截器 this.$axios.interceptors.response.use((res)=&gt;&#123; if（res .headers.token)&#123; //获取服务器的响应头 var token = res.headers.token ; localStroage.setItem(&apos;token&apos;,token) ; &#125; return res.config;&#125;)]]></content>
      <categories>
        <category>axios</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>前后端交互</tag>
        <tag>http请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实现computed原理]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E5%AE%9E%E7%8E%B0computed%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[每当问到VueJS响应式原理，大家可能都会脱口而出“Vue通过Object.defineProperty方法把data对象的全部属性转化成getter/setter，当属性被访问或修改时通知变化”。然而，其内部深层的响应式原理可能很多人都没有完全理解，网络上关于其响应式原理的文章质量也是参差不齐，大多是贴个代码加段注释了事。本文将会从一个非常简单的例子出发，一步一步分析响应式原理的具体实现思路。 一、使数据对象变得“可观测” 首先，我们定义一个数据对象，就以王者荣耀里面的其中一个英雄为例子： const hero = { health: 3000, IQ: 150 } 我们定义了这个英雄的生命值为3000，IQ为150。但是现在还不知道他是谁，不过这不重要，只需要知道这个英雄将会贯穿我们整篇文章，而我们的目的就是通过这个英雄的属性，知道这个英雄是谁。 现在我们可以通过hero.health和hero.IQ直接读写这个英雄对应的属性值。但是，当这个英雄的属性被读取或修改时，我们并不知情。那么应该如何做才能够让英雄主动告诉我们，他的属性被修改了呢？这时候就需要借助Object.defineProperty的力量了。 关于Object.defineProperty的介绍，MDN上是这么说的： Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。在本文中，我们只使用这个方法使对象变得“可观测”，更多关于这个方法的具体内容，请参考https://developer.mozilla.org...，就不再赘述了。 那么如何让这个英雄主动通知我们其属性的读写情况呢？首先改写一下上面的例子： let hero = {} let val = 3000 Object.defineProperty(hero, &apos;health&apos;, { get () { console.log(&apos;我的health属性被读取了！&apos;) return val }, set (newVal) { console.log(&apos;我的health属性被修改了！&apos;) val = newVal } }) 我们通过Object.defineProperty方法，给hero定义了一个health属性，这个属性在被读写的时候都会触发一段console.log。现在来尝试一下： console.log(&apos;我的health属性被读取了！&apos;) // -&gt; 3000 // -&gt; 我的health属性被读取了！ hero.health = 5000 // -&gt; 我的health属性被修改了 可以看到，英雄已经可以主动告诉我们其属性的读写情况了，这也意味着，这个英雄的数据对象已经是“可观测”的了。为了把英雄的所有属性都变得可观测，我们可以想一个办法： /** * 使一个对象转化成可观测对象 * @param { Object } obj 对象 * @param { String } key 对象的key * @param { Any } val 对象的某个key的值 */ function defineReactive (obj, key, val) { Object.defineProperty(obj, key, { get () { // 触发getter console.log(`我的${key}属性被读取了！`) return val }, set (newVal) { // 触发setter console.log(`我的${key}属性被修改了！`) val = newVal } }) } /** * 把一个对象的每一项都转化成可观测对象 * @param { Object } obj 对象 */ function observable (obj) { const keys = Object.keys(obj) keys.forEach((key) =&gt; { defineReactive(obj, key, obj[key]) }) return obj } 现在我们可以把英雄这么定义： const hero = observable({ health: 3000, IQ: 150 }) 读者们可以在控制台自行尝试读写英雄的属性，看看它是不是已经变得可观测的。 二、计算属性 现在，英雄已经变得可观测，任何的读写操作他都会主动告诉我们，但也仅此而已，我们仍然不知道他是谁。如果我们希望在修改英雄的生命值和IQ之后，他能够主动告诉他的其他信息，这应该怎样才能办到呢？假设可以这样： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) 我们定义了一个watcher作为“监听器”，它监听了hero的type属性。这个type属性的值取决于hero.health，换句话来说，当hero.health发生变化时，hero.type也应该发生变化，前者是后者的依赖。我们可以把这个hero.type称为“计算属性”。 那么，我们应该怎样才能正确构造这个监听器呢？可以看到，在设想当中，监听器接收三个参数，分别是被监听的对象、被监听的属性以及回调函数，回调函数返回一个该被监听属性的值。顺着这个思路，我们尝试着编写一段代码： /** * 当计算属性的值被更新时调用 * @param { Any } val 计算属性的值 */ function onComputedUpdate (val) { console.log(`我的类型是：${val}`); } /** * 观测者 * @param { Object } obj 被观测对象 * @param { String } key 被观测对象的key * @param { Function } cb 回调函数，返回“计算属性”的值 */ function watcher (obj, key, cb) { Object.defineProperty(obj, key, { get () { const val = cb() onComputedUpdate(val) return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } 现在我们可以把英雄放在监听器里面，尝试跑一下上面的代码： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) hero.type hero.health = 5000 hero.type // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：脆皮 // -&gt; 我的health属性被修改了！ // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：坦克 现在看起来没毛病，一切都运行良好，是不是就这样结束了呢？别忘了，我们现在是通过手动读取hero.type来获取这个英雄的类型，并不是他主动告诉我们的。如果我们希望让英雄能够在health属性被修改后，第一时间主动发起通知，又该怎么做呢？这就涉及到本文的核心知识点——依赖收集。 三、依赖收集 我们知道，当一个可观测对象的属性被读写时，会触发它的getter/setter方法。换个思路，如果我们可以在可观测对象的getter/setter里面，去执行监听器里面的onComputedUpdate()方法，是不是就能够实现让对象主动发出通知的功能呢？ 由于监听器内的onComputedUpdate()方法需要接收回调函数的值作为参数，而可观测对象内并没有这个回调函数，所以我们需要借助一个第三方来帮助我们把监听器和可观测对象连接起来。 这个第三方就做一件事情——收集监听器内的回调函数的值以及onComputedUpdate()方法。 现在我们把这个第三方命名为“依赖收集器”，一起来看看应该怎么写： const Dep = { target: null } 就是这么简单。依赖收集器的target就是用来存放监听器里面的onComputedUpdate()方法的。 定义完依赖收集器，我们回到监听器里，看看应该在什么地方把onComputedUpdate()方法赋值给Dep.target： function watcher (obj, key, cb) { // 定义一个被动触发函数，当这个“被观测对象”的依赖更新时调用 const onDepUpdated = () =&gt; { const val = cb() onComputedUpdate(val) } Object.defineProperty(obj, key, { get () { Dep.target = onDepUpdated // 执行cb()的过程中会用到Dep.target， // 当cb()执行完了就重置Dep.target为null const val = cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } 我们在监听器内部定义了一个新的onDepUpdated()方法，这个方法很简单，就是把监听器回调函数的值以及onComputedUpdate()给打包到一块，然后赋值给Dep.target。这一步非常关键，通过这样的操作，依赖收集器就获得了监听器的回调值以及onComputedUpdate()方法。作为全局变量，Dep.target理所当然的能够被可观测对象的getter/setter所使用。 重新看一下我们的watcher实例： watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) 在它的回调函数中，调用了英雄的health属性，也就是触发了对应的getter函数。理清楚这一点很重要，因为接下来我们需要回到定义可观测对象的defineReactive()方法当中，对它进行改写： function defineReactive (obj, key, val) { const deps = [] Object.defineProperty(obj, key, { get () { if (Dep.target &amp;&amp; deps.indexOf(Dep.target) === -1) { deps.push(Dep.target) } return val }, set (newVal) { val = newVal deps.forEach((dep) =&gt; { dep() }) } }) } 可以看到，在这个方法里面我们定义了一个空数组deps，当getter被触发的时候，就会往里面添加一个Dep.target。回到关键知识点Dep.target等于监听器的onComputedUpdate()方法，这个时候可观测对象已经和监听器捆绑到一块。任何时候当可观测对象的setter被触发时，就会调用数组中所保存的Dep.target方法，也就是自动触发监听器内部的onComputedUpdate()方法。 至于为什么这里的deps是一个数组而不是一个变量，是因为可能同一个属性会被多个计算属性所依赖，也就是存在多个Dep.target。定义deps为数组，若当前属性的setter被触发，就可以批量调用多个计算属性的onComputedUpdate()方法了。 完成了这些步骤，基本上我们整个响应式系统就已经搭建完成，下面贴上完整的代码： /** * 定义一个“依赖收集器” */ const Dep = { target: null } /** * 使一个对象转化成可观测对象 * @param { Object } obj 对象 * @param { String } key 对象的key * @param { Any } val 对象的某个key的值 */ function defineReactive (obj, key, val) { const deps = [] Object.defineProperty(obj, key, { get () { console.log(`我的${key}属性被读取了！`) if (Dep.target &amp;&amp; deps.indexOf(Dep.target) === -1) { deps.push(Dep.target) } return val }, set (newVal) { console.log(`我的${key}属性被修改了！`) val = newVal deps.forEach((dep) =&gt; { dep() }) } }) } /** * 把一个对象的每一项都转化成可观测对象 * @param { Object } obj 对象 */ function observable (obj) { const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i], obj[keys[i]]) } return obj } /** * 当计算属性的值被更新时调用 * @param { Any } val 计算属性的值 */ function onComputedUpdate (val) { console.log(`我的类型是：${val}`) } /** * 观测者 * @param { Object } obj 被观测对象 * @param { String } key 被观测对象的key * @param { Function } cb 回调函数，返回“计算属性”的值 */ function watcher (obj, key, cb) { // 定义一个被动触发函数，当这个“被观测对象”的依赖更新时调用 const onDepUpdated = () =&gt; { const val = cb() onComputedUpdate(val) } Object.defineProperty(obj, key, { get () { Dep.target = onDepUpdated // 执行cb()的过程中会用到Dep.target， // 当cb()执行完了就重置Dep.target为null const val = cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } const hero = observable({ health: 3000, IQ: 150 }) watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }) console.log(`英雄初始类型：${hero.type}`) hero.health = 5000 // -&gt; 我的health属性被读取了！ // -&gt; 英雄初始类型：脆皮 // -&gt; 我的health属性被修改了！ // -&gt; 我的health属性被读取了！ // -&gt; 我的类型是：坦克 上述代码可以直接在code pen点击预览或者浏览器控制台上执行。 四、代码优化在上面的例子中，依赖收集器只是一个简单的对象，其实在defineReactive()内部的deps数组等和依赖收集有关的功能，都应该集成在Dep实例当中，所以我们可以把依赖收集器改写一下： class Dep { constructor () { this.deps = [] } depend () { if (Dep.target &amp;&amp; this.deps.indexOf(Dep.target) === -1) { this.deps.push(Dep.target) } } notify () { this.deps.forEach((dep) =&gt; { dep() }) } } Dep.target = null 同样的道理，我们对observable和watcher都进行一定的封装与优化，使这个响应式系统变得模块化： class Observable { constructor (obj) { return this.walk(obj) } walk (obj) { const keys = Object.keys(obj) keys.forEach((key) =&gt; { this.defineReactive(obj, key, obj[key]) }) return obj } defineReactive (obj, key, val) { const dep = new Dep() Object.defineProperty(obj, key, { get () { dep.depend() return val }, set (newVal) { val = newVal dep.notify() } }) } } class Watcher { constructor (obj, key, cb, onComputedUpdate) { this.obj = obj this.key = key this.cb = cb this.onComputedUpdate = onComputedUpdate return this.defineComputed() } defineComputed () { const self = this const onDepUpdated = () =&gt; { const val = self.cb() this.onComputedUpdate(val) } Object.defineProperty(self.obj, self.key, { get () { Dep.target = onDepUpdated const val = self.cb() Dep.target = null return val }, set () { console.error(&apos;计算属性无法被赋值！&apos;) } }) } } 然后我们来跑一下： const hero = new Observable({ health: 3000, IQ: 150 }) new Watcher(hero, &apos;type&apos;, () =&gt; { return hero.health &gt; 4000 ? &apos;坦克&apos; : &apos;脆皮&apos; }, (val) =&gt; { console.log(`我的类型是：${val}`) }) console.log(`英雄初始类型：${hero.type}`) hero.health = 5000 // -&gt; 英雄初始类型：脆皮 // -&gt; 我的类型是：坦克]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>computed</tag>
        <tag>响应式</tag>
        <tag>数据绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue路由]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Vue Router是Vue.js的官方路由器。它与Vue.js核心深度集成，使用Vue.js构建单页应用程序变得轻而易举。 使用步骤 引入vue-router对象 安装插件：Vue.use(VueRouter) 创建一个路由对象 var router = new VueRouter（{routes：[]}） 配置路由对象 :routes:[{path:’/login/:name’,component:xx} ] 将配置好的路由对象关联到事列中:router:router 指定路由改变局部的位置:router-link ：to=‘’ 查询字符串 配置：to =“{name:’detail’,query:{id:hero.id} }” 规则：{name：‘detail’,path:’/detail’,component:Detail} 获取：this.$route.query.id 生成： path方式 配置：to =“{name:’detail’,params:{id:hero.id} }” 规则：{name：‘detail’,path:’/detail’/ :id} 获取：this.$route.params.id 生成：path方式需要在路由规则中声明位置 vue-router中的对象 $route路由信息对象，只读对象 $router路由操作对象，只写对象 嵌套路由单页面应用开发多页面的路由。多个组件按不同的锚点值填入不同的位置使用规则： router-view中包含router-view 路由规则中存在子路由 辅助知识点 路由meta元数据—-meta对于路由规则是否需要验证权限的配置,路由对象中和name属性同级 {meta：{isChecked：true}} 路由钩子—权限控制的函数执行时期 每次路由匹配后，渲染组件到router-view之前 router.beforeEach(function(to,from,next){ }):next()直接放行，next(){}跳转到相应的路由]]></content>
      <categories>
        <category>Vue知识点总结</category>
      </categories>
      <tags>
        <tag>路由，vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue基础知识点]]></title>
    <url>%2F2019%2F01%2F03%2FVue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[基础知识点框架与库的区别jquery库+DOM操作+http请求 = 全家桶 如何起步 引包Vue.js 通过Vue对象，new Vue（options） 配置options对象 el:发生动作的目的地 template:模板（必须为一个根节点） data函数，返回的是一个对象 components:key是组件名，value是组件对象 methods：配合事件 props：子组件接受的参数设置 插值表达式：对象、字符串、判断后的布尔值、三元表达式#### 常用指令 - v-text:元素的innerText属性 - v-html：元素的innerHTML属性 - v-if:判断是否插入，v-else-if，v-else和v-if必须是相邻的元素 - v-show:隐藏元素，给元素加上display：none - v-bind:绑定属性，单向数据流,v-bind:属性=‘变量’ 简写：属性名=‘xxx’ - v-model：双向数据绑定，v-on:事件名=‘函数’ 简写： @事件名 - v-on:绑定事件，处理自定义原生事件，v-on:事件名=“表达式 ||函数名 ” - v-for:循环 用法：v-for=“item in stus” 如果stus为数组，（item，index） in stus 如果stus为obj，（value,key,index） in stus#### 全局组件场景：公共性功能组件，减少冗余代码全局API：Vue.component(‘组件名’，组件对象)#### 过滤器给数据的显示进行操作，如反转，改变属性等filter：全局过滤器，Vue.filter(‘过滤器名’，过滤方式fun)filters：组件内的过滤器，Vue.filters(‘过滤器名’，过滤方式fun)，使用:内容 | 过滤器名#### watch监视单个属性改变，无法监视复杂类型，因为监视的是对象地址，地址没有改变，改变的只是属性#### computed监视多个：object | array computed：{ 监视的业务名:function(){}} 使用： slotvue内置的组件，父组件向子组件传DOM结构，而props是动态的数据，如果有选择性传递，就具名插槽，以name来选择，使用的对应的slot=name值即可 组件生命周期所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 beforeCreate：组件创建之前，拿不到数据 created:可以操作数据，并且可以实现vue-&gt;页面的额影响，用于发起http请求 beforeMount：vue起作用，装载数据到DOM之前，应用：vue启动前的DOM mounted：vue起作用，装载数据到DOM之前，应用：vue启动后的DOM，仅执行一次 beforeUpdate:基于数据的改变才会触发，数据改变之前，应用：获取原DOM updated：基于数据的改变才会触发，数据改变之后,应用：获取新DOM beforeDestroy：销毁前，做一些功能的释放，如本地保存 destroyed：销毁后 activated：激活 deactivated：停用 小结：频繁的销毁和创建组件？不合理，使用keep_alive内置组件包裹起来，对应的是actived和deactived声明周期；created和actived：都是子组件状态，created没有被keep-alive内置组件包括，actived被包裹； 获取DOM元素在组件的DOM部分任意标签写上ref=”xxx”,通过组件对象，this.$refs.xxx获取到元素]]></content>
      <categories>
        <category>Vue知识点总结</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>指令</tag>
        <tag>生命周期 ，组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2018]]></title>
    <url>%2F2018%2F12%2F30%2F%E6%88%91%E7%9A%842018%2F</url>
    <content type="text"><![CDATA[前言感觉今年过的很快，其实回头看看经历了很多很多。在2018的尾巴上，回顾这一年的经历，只为明年做的更好。 回首过去关于学习这一年，教研室从一楼搬到了五楼，搬砖的工作量也相应的随楼层的增加而增加。前前后后忙了两个项目，主要的技术栈是bootstrap、Vue、elementUI、webpack等开发工具，那段时间很忙，很头疼，因为没有前辈指导，所有踩的坑都得一个一个一遍又一遍的踩，却感觉很充实，那段时间是自己知识积累最快的一个阶段了吧。后面的一段时间自学了小程序，自己也开发了一个小程序、因审核内容受限、所以没上线。方向是好的，自己可以拿来练练手。12月，联系了一个前辈、打算慢慢参与开源，虽然目前来说是一些维护的事，但也好在为来年的计划做点铺垫。其他方面，学会了烘培、拉花、做咖啡，学会了游泳，也尝试了未曾尝试过的菜肴。 关于秋招秋招算是自己沉淀知识的阶段，年初买的红皮书、权威指南等前端方面的书籍也在秋招的时候看了个遍。过程总的来说很幸运也很遗憾，幸运的是在6月就拿了一个研究所的offer，心里也不是特别的慌；遗憾的是因错过阿里三面的电话而失之交臂，投提前批，找内推就如同石沉大海，没有回应。后面去上海参加上汽举行的“摩尔100计划”，也算散心了，运气也好了起来，最后拿到的offer中，有高薪资的、有发展好的，没有选择最高薪资的、也没有选择发展最好的，而是选择了自己觉得最适合的公司吧。对于秋招的总结，大概就是以下几点： 基础知识要扎实，特别是css，js方面。 在js方面，不仅要有基础，更要有深度。 框架方面，不能只会用，更要了解原理，深入源码 工程方面，要考虑到网络通信、上线bug、维护的问题。 知识的广度，不能局限在前端，后台、安全也很重要。 要有大前端的思想，不能局限在一个模子里面。 关于毕设作为一个前端开发，毕设做人脸识别也算是一种挑战，当找完工作回归教研室看我的开题报告的时候，我第一反应这谁的毕设？谁写的开题报告？我为啥做这个？典型的灵魂三问，然而我不知道系列。疯狂的看英文文献，找创新点，标数据集，训练模型，路途还很遥远，壮士还需努力啊。 关于健身2018年参加了人生第一场正式的马拉松、没有想象中那么难、只是需要坚持下去就好了，路途中有很多让我很感动的风景：单腿带着拐杖走的人，年过七旬的人，坐在轮椅里的人，带着小孩坚持走的人；你会发现，比你优秀的、没你生来完善的人都在努力坚持着自己的生活、你还有什么理由不努力呢？2018年坚持健身的又一年，很庆幸自己没有理由的坚持了下来并养成了习惯，因为是阳光的、美好的，所以更想去坚持吧。 关于旅行18年去的地方不多也不少，时常怀念自己大学毕业义工旅行的日子，真正做到随遇而安的小安，开了属于自己的民宿的露露，她们都走上了自己喜欢的那条路。对于旅行，我一直是坚持的，在路上的。这一年徒步了白雪皑皑的四人同、带老妈小弟逛了成都、打卡了上海、自驾了川西大环线，又一次去了色达，遇见了稻城，更遇见了自己。 展望未来保持对生活的热情，保持内心的孩子气，做自己想做的事情，无论生活变成什么样子，可以受苦，可以跌倒，可以失落，但是不能当废柴。努力做好下面的： 因上努力，果上随缘 好好学习，顺利毕业 多多读书，坚持阅读 努力工作，尽早适应 参与开源，多看源码 做好总结，及时更博 坚持锻炼，坚持健身 做好理财，出去旅行 自爱沉稳，而后爱人 都说2019年属猪的一年，肯定不缺肉吃。我想我的2019年，少点焦虑，多点自律。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阮一峰ES6之Promise对象的理解]]></title>
    <url>%2F2018%2F12%2F30%2F%E9%98%AE%E4%B8%80%E5%B3%B0ES6%E4%B9%8BPromise%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、Promise的含义 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。Promise对象的特点（1）对象的状态不受外界影响，promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来“承若”；（2）一旦状态改变就不会再变，任何时候都可以得到这个结果，promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果，这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。二、用法创建一个实例： const promise = new Promise(function(resolve,reject){ //some code if(//异步操作成功){ resolve(value); }else{ reject(error); } });Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。Promise 新建后就会立即执行。 let promise = new Promise(function(resolve, reject) { console.log(‘Promise’); resolve(); }); promise.then(function() { console.log(‘resolved.’); }); console.log(‘Hi!’); 执行结果：上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 // Promise // Hi! // resolved下面是一个用Promise对象实现的 Ajax 操作的例子。 const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(“GET”, url); client.onreadystatechange = handler; client.responseType = “json”; client.setRequestHeader(“Accept”, “application/json”); client.send(); }); return promise; }; getJSON(“/posts.json”).then(function(json) { console.log(‘Contents: ‘ + json); }, function(error) { console.error(‘出错了’, error); });上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。如果调用resolve函数和reject函数时带有参数，那么他们的参数会被传递给回调函数，reject函数的参数通常是Error对象的实例，表示抛出的错误，resolve函数的参数除了正常的值以外，还可以是另一个promise实例； var p1 = new Promise(function (resolve, reject) { // … }); var p2 = new Promise(function (resolve, reject) { // … resolve(p1); }) p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。三、Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(“/posts.json”).then(function(json) { return json.post; }).then(function(post) { // … });上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。四、Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 getJSON(‘/posts.json’).then(function(posts) { // … }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(‘发生错误！’, error); });上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。五、Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]);上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。下面是一个具体的例子。 // 生成一个Promise对象的数组 const promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(‘/post/‘ + id + “.json”); }); Promise.all(promises).then(function (posts) { // … }).catch(function(reason){ // … });上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。下面是另一个例子。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result) .catch(e =&gt; e); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result) .catch(e =&gt; e); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // [“hello”, Error: 报错了]上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 const p1 = new Promise((resolve, reject) =&gt; { resolve(‘hello’); }) .then(result =&gt; result); const p2 = new Promise((resolve, reject) =&gt; { throw new Error(‘报错了’); }) .then(result =&gt; result); Promise.all([p1, p2]) .then(result =&gt; console.log(result)) .catch(e =&gt; console.log(e)); // Error: 报错了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>promise</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数节流与去抖]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E6%8A%96%2F</url>
    <content type="text"><![CDATA[####使用场景以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。 window对象的resize、scroll事件 拖拽时的mousemove事件 射击游戏中的mousedown、keydown事件 文字输入、自动完成的keyup事件 实际上对于window的resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的0执行后续处理。针对这两种需求就出现了debounce和throttle两种解决办法。 ####debounce抖动：如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。接口定义： /** * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行 * @param idle {number} 空闲时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ debounce(idle,action) 简单实现1：利用定时器，让函数执行延迟500毫秒，在500毫秒内如果有函数又被调用则删除上一次调用，这次调用500毫秒后执行，如此往复 window.onscroll = function(){//lazyload(); debounce(lazyload,window); }; function debounce(method,context){ clearTimeout(method.timeout); method.timeout = setTimeout(function(){ method.call(context); },500); } function lazyload(){ console.log(&quot;scroll执行了&quot;+scrollnum); } 简单实现2： 还有一种节流方式，是通过返回闭包的形式，可以设置延迟时间，两者运行的结果是一样，但是我在实际操作的时候设置延迟500时，滚动过了一会才执行了,设置为delay为100的时候在视觉上就没有感觉延迟。而且函数也只滚动了一次。 function debounce1(method,delay){ var timer = null; return function(){ var context = this,args = arguments; clearTimeout(timer); timer = setTimeout(function(){ method.apply(context,args); },delay); } } ####throttle当我一直滚动鼠标的时候，lazyload函数就会不断被延迟，这样只有停下来的时候才会执行，那么再有些需要及时显示的情况下，就显得不那么友好了(对于实现keyup事件的提示也没有意义了)，所以可以为函数添加一个参数作为到固定间隔必须执行，到了这个时间间隔就必须执行，这个时候就引入了节流： 节流：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期接口定义： /** * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay * @param delay {number} 延迟时间，单位毫秒 * @param action {function} 请求关联函数，实际应用需要调用的函数 * @return {function} 返回客户调用函数 */ throttle(delay,action) 简单实现： var throttle = function(delay, action){ var last = 0; return function(){ var curr = +new Date(); if (curr - last &gt; delay){ action.apply(this, arguments); last = curr ; } } } 简单实现2： function throttle2(method, delay, time) { var timeout,startTime = new Date(); return function() { var context = this, args = arguments, curTime = new Date(); clearTimeout(timeout);// 如果达到了规定的触发时间间隔，触发 handler if (curTime - startTime &gt;= time) { method.apply(context, args); startTime = curTime;//没达到触发间隔，重新设定定时器 } else { timeout = setTimeout(method, delay); } };]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之this的指向理解]]></title>
    <url>%2F2018%2F12%2F29%2FJS%E4%B9%8Bthis%E7%9A%84%E6%8C%87%E5%90%91%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.this是什么？ this是对象自动生成的一个内部对象，是在运行时基于函数的执行环境绑定的，因为函数的调用场合不同，this的值也有变化。this指向什么，完全取决于 什么地方以什么方式调用，而不是 创建时 。这句话目前也只能说在ES5中才是正确的，而在ES6的箭头函数中，this的指向就是在定义的时候就确定的。 2. this的绑定规则this的绑定总共差不多有下面五种： 默认绑定 隐式绑定 显示绑定 new绑定 ES6箭头函数中的this2.1.默认绑定12345function foo()&#123; console.log(this.a); // 10&#125;var a = 10;foo(); 作为独立函数的调用，this指向的是全局对象window，而在严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。 2.2.隐式绑定123456789function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;foo(); //undefinedobj.foo(); // 2 foo() 这个就是默认绑定,等价于打印 window.a ,故输出 undefined ；obj.foo()，函数有上下文对象，即obj，这种情况下， 函数里的this默认绑定为上下文对象 ，等价于打印 obj.a ,故输出2 。如果是链性的关系，比如 xx.yy.obj.foo(); , 上下文取函数的直接上级，即紧挨着的那个，或者说对象链的最后一个。再看下一个情况：12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数别名var a =,10; // a是全局对象的属性bar(); // 10 虽然bar为obj.foo的引用，但实际上引用的是foo函数本身，此时this指向为默认绑定，指向的window，所以输出10 2.3.显示绑定 显示绑定就是call apply bind，call和apply它们的作用都是改变函数的this指向 ， 第一个参数都是 设置this对象 。两个函数的区别：call从第二个参数开始所有的参数都是 原函数的参数。apply只接受两个参数，且第二个参数必须是数组，这个数组代表原函数的参数列表。1234567function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 调用foo时强制把foo的this绑定到obj上 bind只有一个函数，且不会立刻执行，只是将一个值绑定到函数的this上,并将绑定好的函数返回。123456function foo()&#123; console.log(this.a);&#125;var obj = &#123; a : 10 &#125;;foo = foo.bind(obj);foo(); // 10 2.4.new绑定js中的只要用new修饰的 函数就是’构造函数’，准确来说是 函数的 构造调用 ，因为在js中并不存在所谓的’构造函数’。那么用new 做到函数的 构造调用 后，js帮我们做了什么工作呢: 1234567function createNew() let obj = new Object() // 创建一个空的对象 let Con = [].shift.call(arguments) // 获得构造函数 obj.__proto__ = Con.prototype // 链接到原型 let result = Con.apply(obj, arguments) // 绑定 this，执行构造函数 return typeof result === &apos;object&apos; ? result : obj // 确保 new 出来的是个对象&#125; 1、创建（或者说构造）一个新对象。2、这个新对象会被执行[[Prototype]]连接。3、这个新对象会绑定到函数调用的this。4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 12345678function foo()&#123; this.a = 10; console.log(this);&#125;foo(); // window对象console.log(window.a); // 10 默认绑定var obj = new foo(); //// 等价于 foo &#123; a : 10 &#125;; var obj = foo; console.log(obj.a); // 10 new绑定 特别注意 : 如果原函数返回一个对象类型，那么将无法返回新对象,你将丢失绑定this的新对象，例: function foo(){ this.a = 10; return new String(&quot;啊哈哈&quot;); } var obj = new foo(); console.log(obj.a); // undefined console.log(obj); // &quot;啊哈哈&quot; 2.5 ES6箭头函数中的thisfoo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。12345678910111213function foo() &#123; return (a) =&gt; &#123; //返回一个箭头函数 console.log( this.a ); // this继承自foo() &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;var bar = foo.call( obj1 );bar.call( obj2 ); // 2，不是3！ 3. 优先级new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 4. 总结1.如果函数是在某个 上下文对象 下被调用：this绑定的是那个上下文对象，例 : var obj = { foo : foo }; obj.foo(); foo 中的 this 就是 obj2.如果函数是使用 call,apply,bind 来调用的：this绑定的是 call,apply,bind 的第一个参数.例: foo.call(obj); , foo 中的 this 就是 obj3.如果函数被 new 修饰：this绑定的是新创建的对象，例:var bar = new foo(); 函数 foo 中的 this 就是一个叫foo的新创建的对象 , 然后将这个对象赋给bar4.如果都不是，则是默认绑定 5.常见题目分析var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); // 20 //隐式绑定,this指向上下文obj var foo = function(){ console.log(this.x); } foo(); //10 默认绑定 指向的是window对象 } }; obj.f(); 12345678function foo(arg)&#123; this.a = arg; return this&#125;;var a = foo(1);var b = foo(10);console.log(a.a); // ?undefinedconsole.log(b.a); // ?10 分析：foo(1)执行，应该不难看出是默认绑定吧 , this指向了window，函数里等价于 window . a = 1,return window;var a = foo(1) 等价于 window . a = window , 很多人都忽略了 var a 就是window.a ，将刚刚赋值的 1 替换掉了。所以这里的 a 的值是 window , a . a 也是window ， 即window . a = window ; window . a . a = window;foo(10) 和第一次一样，都是默认绑定，这个时候， 将window.a 赋值成 10 ，注意这里是关键，原来window.a = window ,现在被赋值成了10，变成了值类型，所以现在 a.a = undefined。(验证这一点只需要将var b = foo(10);删掉，这里的 a.a 还是window)var b = foo(10); 等价于 window.b = window;本题中所有变量的值，a = window.a = 10 , a.a = undefined , b = window , b.a = window.a = 10; 1234567891011121314151617181920var num = 1;var myObject = &#123; num: 2, add: function() &#123; this.num = 3; (function() &#123; console.log(this.num); //默认绑定 指向的window 输出1 this.num = 4; &#125;)(); console.log(this.num); &#125;, sub: function() &#123; console.log(this.num) &#125;&#125;myObject.add(); console.log(myObject.num); console.log(num);var sub = myObject.sub;sub(); 依次输出 1 3 3 4 4]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈我对vuex的理解]]></title>
    <url>%2F2018%2F12%2F29%2F%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Vuex%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在近期做得项目中，用到Vue框架，必不可少的也用到vuex状态管理，再加上面试中也被问到了，索性把这一块拿出来抽时间整理一下： 核心概念Vuex 是适用于 Vue.js 应用的状态管理库，为应用中的所有组件提供集中式的状态存储与操作，保证了所有状态以可预测的方式进行修改。官网的一张图： Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，重新渲染Vue Components，界面随之更新 完整流程 单向数据流规定所有的数据操作必须通过 action – mutation – state change 的流程来进行，再结合Vue的数据视图双向绑定特性来实现页面的展示更新 state单一状态树那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： // 创建一个 Counter 组件 const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return store.state.count } } } 然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： const app = new Vue({ el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; ` }) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： 12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from &apos;vuex&apos; export default { computed: mapState({ count: state =&gt; state.count, // 传字符串参数 &apos;count&apos; 等同于 `state =&gt; state.count` countAlias: &apos;count&apos;, // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：而且Mutation必须为同步函数当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：store.commit(‘increment’) const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) ActionAction 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(&apos;increment&apos;) } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 分发 ActionAction 通过 store.dispatch 方法触发：store.dispatch(‘increment’)在组件中分发 Action:在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）： import { mapActions } from &apos;vuex&apos; export default { methods: { ...mapActions([ &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` // `mapActions` 也支持载荷： &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&apos;incrementBy&apos;, amount)` ]), ...mapActions({ add: &apos;increment&apos; // 将 `this.add()` 映射为 `this.$store.dispatch(&apos;increment&apos;)` }) }}]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>vuex</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
</search>
